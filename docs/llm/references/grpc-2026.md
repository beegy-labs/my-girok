# gRPC - 2026 Best Practices

> High-performance RPC, Protocol Buffers, Node.js microservices | **Researched**: 2026-01-22

## Overview

| Feature         | Value                                |
| --------------- | ------------------------------------ |
| Protocol        | HTTP/2 + Protocol Buffers            |
| Serialization   | Binary (10x smaller than JSON)       |
| Streaming       | Unary, Server, Client, Bidirectional |
| Code Generation | Multi-language from .proto files     |

## Project Structure

```
packages/proto/
├── buf.yaml
├── buf.gen.yaml
└── src/
    ├── user/
    │   └── v1/
    │       └── user.proto
    ├── auth/
    │   └── v1/
    │       └── auth.proto
    └── common/
        └── v1/
            └── types.proto
```

## Protocol Buffer Design

### Service Definition

```protobuf
syntax = "proto3";

package user.v1;

import "google/protobuf/timestamp.proto";
import "common/v1/types.proto";

service UserService {
  // Unary RPC
  rpc GetUser(GetUserRequest) returns (GetUserResponse);

  // Server streaming
  rpc ListUsers(ListUsersRequest) returns (stream User);

  // Client streaming
  rpc BatchCreateUsers(stream CreateUserRequest) returns (BatchCreateUsersResponse);

  // Bidirectional streaming
  rpc SyncUsers(stream SyncRequest) returns (stream SyncResponse);
}

message GetUserRequest {
  string id = 1;
}

message GetUserResponse {
  User user = 1;
}

message User {
  string id = 1;
  string email = 2;
  string name = 3;
  UserStatus status = 4;
  google.protobuf.Timestamp created_at = 5;
}

enum UserStatus {
  USER_STATUS_UNSPECIFIED = 0;
  USER_STATUS_ACTIVE = 1;
  USER_STATUS_INACTIVE = 2;
  USER_STATUS_SUSPENDED = 3;
}
```

### Proto Best Practices

| Rule                      | Example              | Reason                |
| ------------------------- | -------------------- | --------------------- |
| Use packages              | `package user.v1;`   | Namespace isolation   |
| Version in path           | `user/v1/user.proto` | API evolution         |
| Enum zero value           | `UNSPECIFIED = 0`    | Default handling      |
| Reserved fields           | `reserved 5, 6;`     | Safe field removal    |
| Never reuse field numbers | -                    | Wire format stability |

## Buf Configuration

### buf.yaml

```yaml
version: v2
modules:
  - path: src
lint:
  use:
    - STANDARD
    - COMMENTS
  except:
    - PACKAGE_VERSION_SUFFIX
breaking:
  use:
    - FILE
```

### buf.gen.yaml

```yaml
version: v2
plugins:
  - remote: buf.build/connectrpc/es
    out: gen/ts
    opt:
      - target=ts
  - remote: buf.build/protocolbuffers/js
    out: gen/ts
    opt:
      - import_style=commonjs
      - binary
```

## Node.js Implementation

### Server Setup

```typescript
import { Server, ServerCredentials } from '@grpc/grpc-js';
import { UserServiceService } from './generated/user/v1/user_grpc_pb';
import { userServiceImpl } from './services/user.service';

const server = new Server({
  'grpc.max_receive_message_length': 4 * 1024 * 1024, // 4MB
  'grpc.max_send_message_length': 4 * 1024 * 1024,
  'grpc.keepalive_time_ms': 10000,
  'grpc.keepalive_timeout_ms': 5000,
});

server.addService(UserServiceService, userServiceImpl);

server.bindAsync('0.0.0.0:50051', ServerCredentials.createInsecure(), (err, port) => {
  if (err) throw err;
  console.log(`gRPC server running on port ${port}`);
});
```

### Service Implementation

```typescript
import { sendUnaryData, ServerUnaryCall } from '@grpc/grpc-js';
import { GetUserRequest, GetUserResponse, User } from './generated/user/v1/user_pb';

export const userServiceImpl = {
  async getUser(
    call: ServerUnaryCall<GetUserRequest, GetUserResponse>,
    callback: sendUnaryData<GetUserResponse>,
  ): Promise<void> {
    try {
      const userId = call.request.getId();

      const userData = await prisma.user.findUnique({
        where: { id: userId },
      });

      if (!userData) {
        return callback({
          code: grpc.status.NOT_FOUND,
          message: 'User not found',
        });
      }

      const user = new User();
      user.setId(userData.id);
      user.setEmail(userData.email);
      user.setName(userData.name);

      const response = new GetUserResponse();
      response.setUser(user);

      callback(null, response);
    } catch (error) {
      callback({
        code: grpc.status.INTERNAL,
        message: error.message,
      });
    }
  },
};
```

### Client Setup

```typescript
import { credentials, Metadata } from '@grpc/grpc-js';
import { UserServiceClient } from './generated/user/v1/user_grpc_pb';
import { GetUserRequest } from './generated/user/v1/user_pb';

const client = new UserServiceClient('localhost:50051', credentials.createInsecure(), {
  'grpc.keepalive_time_ms': 10000,
  'grpc.keepalive_timeout_ms': 5000,
  'grpc.max_reconnect_backoff_ms': 10000,
});

async function getUser(userId: string): Promise<User> {
  return new Promise((resolve, reject) => {
    const request = new GetUserRequest();
    request.setId(userId);

    const metadata = new Metadata();
    metadata.set('authorization', `Bearer ${token}`);

    // Set deadline
    const deadline = new Date();
    deadline.setSeconds(deadline.getSeconds() + 5);

    client.getUser(request, metadata, { deadline }, (err, response) => {
      if (err) return reject(err);
      resolve(response.getUser());
    });
  });
}
```

## Interceptors

### Server Interceptor (Logging)

```typescript
import { ServerInterceptingCall, ServerListenerBuilder } from '@grpc/grpc-js';

function loggingInterceptor(methodDescriptor, call) {
  const listener = new ServerListenerBuilder()
    .withOnReceiveMessage((message, next) => {
      console.log(`Received: ${methodDescriptor.path}`);
      next(message);
    })
    .build();

  return new ServerInterceptingCall(call, { listener });
}
```

### Client Interceptor (Auth Token)

```typescript
function authInterceptor(options, nextCall) {
  return new InterceptingCall(nextCall(options), {
    start(metadata, listener, next) {
      metadata.set('authorization', `Bearer ${getToken()}`);
      next(metadata, listener);
    },
  });
}

const client = new UserServiceClient(address, credentials, {
  interceptors: [authInterceptor],
});
```

## Streaming Patterns

### Server Streaming

```typescript
// Server
async listUsers(call: ServerWritableStream<ListUsersRequest, User>): Promise<void> {
  const users = await prisma.user.findMany({ take: 100 });

  for (const user of users) {
    const protoUser = new User();
    protoUser.setId(user.id);
    protoUser.setEmail(user.email);
    call.write(protoUser);
  }

  call.end();
}

// Client
const stream = client.listUsers(request);
stream.on('data', (user) => console.log(user.getId()));
stream.on('end', () => console.log('Stream ended'));
stream.on('error', (err) => console.error(err));
```

## Error Handling

### gRPC Status Codes

| Code | Name              | Use Case               |
| ---- | ----------------- | ---------------------- |
| 0    | OK                | Success                |
| 3    | INVALID_ARGUMENT  | Bad request data       |
| 5    | NOT_FOUND         | Resource doesn't exist |
| 7    | PERMISSION_DENIED | Auth failure           |
| 13   | INTERNAL          | Server error           |
| 14   | UNAVAILABLE       | Service unavailable    |

### Error Response

```typescript
import { status } from '@grpc/grpc-js';

callback({
  code: status.NOT_FOUND,
  message: 'User not found',
  details: JSON.stringify({ userId, timestamp: Date.now() }),
});
```

## Performance Guidelines

| Setting      | Recommendation        | Reason             |
| ------------ | --------------------- | ------------------ |
| Deadlines    | Always set            | Prevent hung calls |
| Keep-alive   | 10-30s                | Connection health  |
| Message size | Limit to 4MB          | Memory protection  |
| Backpressure | Handle in streaming   | Flow control       |
| Interceptors | Use for cross-cutting | DRY principle      |

## Load Balancing

### Client-Side (Recommended)

```typescript
const client = new UserServiceClient(
  'dns:///user-service:50051', // DNS-based discovery
  credentials.createInsecure(),
  {
    'grpc.service_config': JSON.stringify({
      loadBalancingConfig: [{ round_robin: {} }],
    }),
  },
);
```

## Anti-Patterns

| Don't               | Do                      | Reason             |
| ------------------- | ----------------------- | ------------------ |
| No deadlines        | Always set timeouts     | Prevent hangs      |
| Large payloads      | Stream or paginate      | Memory/latency     |
| Reuse field numbers | Reserve deleted fields  | Wire compatibility |
| Skip versioning     | Version in package path | API evolution      |
| Sync-only calls     | Use async/await         | Performance        |

## Sources

- [gRPC Node.js Tutorial](https://daily.dev/blog/build-a-grpc-service-in-nodejs)
- [gRPC Node.js TypeScript Guide](https://oneuptime.com/blog/post/2026-01-08-grpc-nodejs-typescript/view)
- [Advanced gRPC in Microservices](https://dzone.com/articles/advanced-grpc-in-microservices)
- [gRPC Official Node Basics](https://grpc.io/docs/languages/node/basics/)
- [High-Performance Microservices with gRPC](https://medium.com/cloud-native-daily/building-high-performance-microservices-with-node-js-grpc-and-typescript-ddef5e0bdb95)
