/**
 * AST Types for Authorization DSL
 *
 * These types represent the Abstract Syntax Tree generated by the parser.
 * The AST is then compiled into the runtime AuthorizationModel.
 *
 * DSL Grammar:
 * ```
 * model         → "model" "schema" VERSION type*
 * type          → "type" IDENTIFIER relations?
 * relations     → "relations" relation*
 * relation      → "define" IDENTIFIER ":" rewrite
 * rewrite       → directTypes | computed | tupleToUserset | booleanExpr
 * directTypes   → "[" IDENTIFIER ("," IDENTIFIER)* "]"
 * computed      → IDENTIFIER
 * tupleToUserset → IDENTIFIER "->" IDENTIFIER
 * booleanExpr   → term (("or" | "and") term)*
 * term          → rewrite ("but" "not" rewrite)?
 * ```
 */

/**
 * Source location for error reporting
 */
export interface SourceLocation {
  line: number;
  column: number;
  offset: number;
}

/**
 * Base interface for all AST nodes
 */
export interface ASTNode {
  kind: string;
  location?: SourceLocation;
}

/**
 * Root node of the AST
 */
export interface ModelAST extends ASTNode {
  kind: 'Model';
  schemaVersion: string;
  types: TypeAST[];
}

/**
 * Type definition node
 */
export interface TypeAST extends ASTNode {
  kind: 'Type';
  name: string;
  relations: RelationAST[];
}

/**
 * Relation definition node
 */
export interface RelationAST extends ASTNode {
  kind: 'Relation';
  name: string;
  rewrite: RewriteAST;
}

/**
 * Base interface for rewrite AST nodes
 */
export interface BaseRewriteAST extends ASTNode {
  kind: string;
}

/**
 * Direct assignment rewrite
 * DSL: [user, admin, team#member]
 */
export interface DirectRewriteAST extends BaseRewriteAST {
  kind: 'DirectRewrite';
  allowedTypes: TypeReferenceAST[];
}

/**
 * Type reference (with optional relation for userset)
 */
export interface TypeReferenceAST extends ASTNode {
  kind: 'TypeReference';
  type: string;
  relation?: string; // Present for userset like "team#member"
}

/**
 * Computed rewrite - reference another relation
 * DSL: admin (references the admin relation)
 */
export interface ComputedRewriteAST extends BaseRewriteAST {
  kind: 'ComputedRewrite';
  relation: string;
}

/**
 * Tuple to userset rewrite
 * DSL: parent_service->can_view
 */
export interface TupleToUsersetRewriteAST extends BaseRewriteAST {
  kind: 'TupleToUsersetRewrite';
  tuplesetRelation: string;
  computedRelation: string;
}

/**
 * Union rewrite (OR logic)
 * DSL: admin or viewer or owner
 */
export interface UnionRewriteAST extends BaseRewriteAST {
  kind: 'UnionRewrite';
  children: RewriteAST[];
}

/**
 * Intersection rewrite (AND logic)
 * DSL: member and verified
 */
export interface IntersectionRewriteAST extends BaseRewriteAST {
  kind: 'IntersectionRewrite';
  children: RewriteAST[];
}

/**
 * Exclusion rewrite (BUT NOT logic)
 * DSL: viewer but not blocked
 */
export interface ExclusionRewriteAST extends BaseRewriteAST {
  kind: 'ExclusionRewrite';
  base: RewriteAST;
  subtract: RewriteAST;
}

/**
 * Union type of all rewrite AST nodes
 */
export type RewriteAST =
  | DirectRewriteAST
  | ComputedRewriteAST
  | TupleToUsersetRewriteAST
  | UnionRewriteAST
  | IntersectionRewriteAST
  | ExclusionRewriteAST;

/**
 * Parser error
 */
export interface ParseError {
  message: string;
  location?: SourceLocation;
}

/**
 * Parse result
 */
export interface ParseResult {
  success: boolean;
  ast?: ModelAST;
  errors: ParseError[];
}

/**
 * Helper to create source location
 */
export function createLocation(line: number, column: number, offset: number): SourceLocation {
  return { line, column, offset };
}

/**
 * Helper to check if an AST node is a specific kind
 */
export function isRewriteKind<T extends RewriteAST>(node: RewriteAST, kind: T['kind']): node is T {
  return node.kind === kind;
}
