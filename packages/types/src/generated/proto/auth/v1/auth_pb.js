// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies,ts_nocheck,add_pb_suffix,output_javascript
// @generated from protobuf file "auth/v1/auth.proto" (package "auth.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies,ts_nocheck,add_pb_suffix,output_javascript
// @generated from protobuf file "auth/v1/auth.proto" (package "auth.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../google/protobuf/timestamp_pb";
/**
 * RoleScope defines where the role applies
 *
 * @generated from protobuf enum auth.v1.RoleScope
 */
export var RoleScope;
(function (RoleScope) {
    /**
     * @generated from protobuf enum value: ROLE_SCOPE_UNSPECIFIED = 0;
     */
    RoleScope[RoleScope["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: ROLE_SCOPE_GLOBAL = 1;
     */
    RoleScope[RoleScope["GLOBAL"] = 1] = "GLOBAL";
    /**
     * @generated from protobuf enum value: ROLE_SCOPE_SERVICE = 2;
     */
    RoleScope[RoleScope["SERVICE"] = 2] = "SERVICE";
    /**
     * @generated from protobuf enum value: ROLE_SCOPE_TENANT = 3;
     */
    RoleScope[RoleScope["TENANT"] = 3] = "TENANT";
})(RoleScope || (RoleScope = {}));
/**
 * OperatorStatus represents the current state of an operator
 *
 * @generated from protobuf enum auth.v1.OperatorStatus
 */
export var OperatorStatus;
(function (OperatorStatus) {
    /**
     * @generated from protobuf enum value: OPERATOR_STATUS_UNSPECIFIED = 0;
     */
    OperatorStatus[OperatorStatus["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: OPERATOR_STATUS_PENDING = 1;
     */
    OperatorStatus[OperatorStatus["PENDING"] = 1] = "PENDING";
    /**
     * @generated from protobuf enum value: OPERATOR_STATUS_ACTIVE = 2;
     */
    OperatorStatus[OperatorStatus["ACTIVE"] = 2] = "ACTIVE";
    /**
     * @generated from protobuf enum value: OPERATOR_STATUS_SUSPENDED = 3;
     */
    OperatorStatus[OperatorStatus["SUSPENDED"] = 3] = "SUSPENDED";
    /**
     * @generated from protobuf enum value: OPERATOR_STATUS_REVOKED = 4;
     */
    OperatorStatus[OperatorStatus["REVOKED"] = 4] = "REVOKED";
})(OperatorStatus || (OperatorStatus = {}));
/**
 * SubjectType identifies what kind of entity is sanctioned
 *
 * @generated from protobuf enum auth.v1.SubjectType
 */
export var SubjectType;
(function (SubjectType) {
    /**
     * @generated from protobuf enum value: SUBJECT_TYPE_UNSPECIFIED = 0;
     */
    SubjectType[SubjectType["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: SUBJECT_TYPE_USER = 1;
     */
    SubjectType[SubjectType["USER"] = 1] = "USER";
    /**
     * @generated from protobuf enum value: SUBJECT_TYPE_OPERATOR = 2;
     */
    SubjectType[SubjectType["OPERATOR"] = 2] = "OPERATOR";
    /**
     * @generated from protobuf enum value: SUBJECT_TYPE_SERVICE = 3;
     */
    SubjectType[SubjectType["SERVICE"] = 3] = "SERVICE";
})(SubjectType || (SubjectType = {}));
/**
 * SanctionType categorizes the sanction
 *
 * @generated from protobuf enum auth.v1.SanctionType
 */
export var SanctionType;
(function (SanctionType) {
    /**
     * @generated from protobuf enum value: SANCTION_TYPE_UNSPECIFIED = 0;
     */
    SanctionType[SanctionType["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: SANCTION_TYPE_WARNING = 1;
     */
    SanctionType[SanctionType["WARNING"] = 1] = "WARNING";
    /**
     * @generated from protobuf enum value: SANCTION_TYPE_MUTE = 2;
     */
    SanctionType[SanctionType["MUTE"] = 2] = "MUTE";
    /**
     * @generated from protobuf enum value: SANCTION_TYPE_TEMPORARY_BAN = 3;
     */
    SanctionType[SanctionType["TEMPORARY_BAN"] = 3] = "TEMPORARY_BAN";
    /**
     * @generated from protobuf enum value: SANCTION_TYPE_PERMANENT_BAN = 4;
     */
    SanctionType[SanctionType["PERMANENT_BAN"] = 4] = "PERMANENT_BAN";
    /**
     * @generated from protobuf enum value: SANCTION_TYPE_FEATURE_RESTRICTION = 5;
     */
    SanctionType[SanctionType["FEATURE_RESTRICTION"] = 5] = "FEATURE_RESTRICTION";
})(SanctionType || (SanctionType = {}));
/**
 * SanctionSeverity indicates the severity level
 *
 * @generated from protobuf enum auth.v1.SanctionSeverity
 */
export var SanctionSeverity;
(function (SanctionSeverity) {
    /**
     * @generated from protobuf enum value: SANCTION_SEVERITY_UNSPECIFIED = 0;
     */
    SanctionSeverity[SanctionSeverity["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: SANCTION_SEVERITY_LOW = 1;
     */
    SanctionSeverity[SanctionSeverity["LOW"] = 1] = "LOW";
    /**
     * @generated from protobuf enum value: SANCTION_SEVERITY_MEDIUM = 2;
     */
    SanctionSeverity[SanctionSeverity["MEDIUM"] = 2] = "MEDIUM";
    /**
     * @generated from protobuf enum value: SANCTION_SEVERITY_HIGH = 3;
     */
    SanctionSeverity[SanctionSeverity["HIGH"] = 3] = "HIGH";
    /**
     * @generated from protobuf enum value: SANCTION_SEVERITY_CRITICAL = 4;
     */
    SanctionSeverity[SanctionSeverity["CRITICAL"] = 4] = "CRITICAL";
})(SanctionSeverity || (SanctionSeverity = {}));
/**
 * SanctionStatus represents the current state of a sanction
 *
 * @generated from protobuf enum auth.v1.SanctionStatus
 */
export var SanctionStatus;
(function (SanctionStatus) {
    /**
     * @generated from protobuf enum value: SANCTION_STATUS_UNSPECIFIED = 0;
     */
    SanctionStatus[SanctionStatus["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: SANCTION_STATUS_ACTIVE = 1;
     */
    SanctionStatus[SanctionStatus["ACTIVE"] = 1] = "ACTIVE";
    /**
     * @generated from protobuf enum value: SANCTION_STATUS_EXPIRED = 2;
     */
    SanctionStatus[SanctionStatus["EXPIRED"] = 2] = "EXPIRED";
    /**
     * @generated from protobuf enum value: SANCTION_STATUS_REVOKED = 3;
     */
    SanctionStatus[SanctionStatus["REVOKED"] = 3] = "REVOKED";
    /**
     * @generated from protobuf enum value: SANCTION_STATUS_APPEALED = 4;
     */
    SanctionStatus[SanctionStatus["APPEALED"] = 4] = "APPEALED";
})(SanctionStatus || (SanctionStatus = {}));
// @generated message type with reflection information, may provide speed optimized methods
class Permission$Type extends MessageType {
    constructor() {
        super("auth.v1.Permission", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resource", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "action", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "category", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "is_system", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.resource = "";
        message.action = "";
        message.category = "";
        message.description = "";
        message.isSystem = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string resource */ 2:
                    message.resource = reader.string();
                    break;
                case /* string action */ 3:
                    message.action = reader.string();
                    break;
                case /* string category */ 4:
                    message.category = reader.string();
                    break;
                case /* string description */ 5:
                    message.description = reader.string();
                    break;
                case /* bool is_system */ 6:
                    message.isSystem = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string resource = 2; */
        if (message.resource !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resource);
        /* string action = 3; */
        if (message.action !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.action);
        /* string category = 4; */
        if (message.category !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.category);
        /* string description = 5; */
        if (message.description !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.description);
        /* bool is_system = 6; */
        if (message.isSystem !== false)
            writer.tag(6, WireType.Varint).bool(message.isSystem);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.Permission
 */
export const Permission = new Permission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Role$Type extends MessageType {
    constructor() {
        super("auth.v1.Role", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "scope", kind: "enum", T: () => ["auth.v1.RoleScope", RoleScope, "ROLE_SCOPE_"] },
            { no: 6, name: "permissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Permission },
            { no: 7, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 8, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.name = "";
        message.description = "";
        message.level = 0;
        message.scope = 0;
        message.permissions = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* int32 level */ 4:
                    message.level = reader.int32();
                    break;
                case /* auth.v1.RoleScope scope */ 5:
                    message.scope = reader.int32();
                    break;
                case /* repeated auth.v1.Permission permissions */ 6:
                    message.permissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp created_at */ 7:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 8:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* int32 level = 4; */
        if (message.level !== 0)
            writer.tag(4, WireType.Varint).int32(message.level);
        /* auth.v1.RoleScope scope = 5; */
        if (message.scope !== 0)
            writer.tag(5, WireType.Varint).int32(message.scope);
        /* repeated auth.v1.Permission permissions = 6; */
        for (let i = 0; i < message.permissions.length; i++)
            Permission.internalBinaryWrite(message.permissions[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 7; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 8; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.Role
 */
export const Role = new Role$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Operator$Type extends MessageType {
    constructor() {
        super("auth.v1.Operator", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "status", kind: "enum", T: () => ["auth.v1.OperatorStatus", OperatorStatus, "OPERATOR_STATUS_"] },
            { no: 6, name: "role_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "role", kind: "message", T: () => Role },
            { no: 8, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 9, name: "updated_at", kind: "message", T: () => Timestamp },
            { no: 10, name: "last_login_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.accountId = "";
        message.email = "";
        message.displayName = "";
        message.status = 0;
        message.roleId = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string account_id */ 2:
                    message.accountId = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                case /* string display_name */ 4:
                    message.displayName = reader.string();
                    break;
                case /* auth.v1.OperatorStatus status */ 5:
                    message.status = reader.int32();
                    break;
                case /* string role_id */ 6:
                    message.roleId = reader.string();
                    break;
                case /* auth.v1.Role role */ 7:
                    message.role = Role.internalBinaryRead(reader, reader.uint32(), options, message.role);
                    break;
                case /* google.protobuf.Timestamp created_at */ 8:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 9:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                case /* google.protobuf.Timestamp last_login_at */ 10:
                    message.lastLoginAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastLoginAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string account_id = 2; */
        if (message.accountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountId);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* string display_name = 4; */
        if (message.displayName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.displayName);
        /* auth.v1.OperatorStatus status = 5; */
        if (message.status !== 0)
            writer.tag(5, WireType.Varint).int32(message.status);
        /* string role_id = 6; */
        if (message.roleId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.roleId);
        /* auth.v1.Role role = 7; */
        if (message.role)
            Role.internalBinaryWrite(message.role, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 8; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 9; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_login_at = 10; */
        if (message.lastLoginAt)
            Timestamp.internalBinaryWrite(message.lastLoginAt, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.Operator
 */
export const Operator = new Operator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sanction$Type extends MessageType {
    constructor() {
        super("auth.v1.Sanction", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subject_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subject_type", kind: "enum", T: () => ["auth.v1.SubjectType", SubjectType, "SUBJECT_TYPE_"] },
            { no: 4, name: "type", kind: "enum", T: () => ["auth.v1.SanctionType", SanctionType, "SANCTION_TYPE_"] },
            { no: 5, name: "severity", kind: "enum", T: () => ["auth.v1.SanctionSeverity", SanctionSeverity, "SANCTION_SEVERITY_"] },
            { no: 6, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "evidence", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "issued_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "issued_at", kind: "message", T: () => Timestamp },
            { no: 10, name: "expires_at", kind: "message", T: () => Timestamp },
            { no: 11, name: "status", kind: "enum", T: () => ["auth.v1.SanctionStatus", SanctionStatus, "SANCTION_STATUS_"] }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.subjectId = "";
        message.subjectType = 0;
        message.type = 0;
        message.severity = 0;
        message.reason = "";
        message.evidence = "";
        message.issuedBy = "";
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string subject_id */ 2:
                    message.subjectId = reader.string();
                    break;
                case /* auth.v1.SubjectType subject_type */ 3:
                    message.subjectType = reader.int32();
                    break;
                case /* auth.v1.SanctionType type */ 4:
                    message.type = reader.int32();
                    break;
                case /* auth.v1.SanctionSeverity severity */ 5:
                    message.severity = reader.int32();
                    break;
                case /* string reason */ 6:
                    message.reason = reader.string();
                    break;
                case /* string evidence */ 7:
                    message.evidence = reader.string();
                    break;
                case /* string issued_by */ 8:
                    message.issuedBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp issued_at */ 9:
                    message.issuedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.issuedAt);
                    break;
                case /* google.protobuf.Timestamp expires_at */ 10:
                    message.expiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
                    break;
                case /* auth.v1.SanctionStatus status */ 11:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string subject_id = 2; */
        if (message.subjectId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subjectId);
        /* auth.v1.SubjectType subject_type = 3; */
        if (message.subjectType !== 0)
            writer.tag(3, WireType.Varint).int32(message.subjectType);
        /* auth.v1.SanctionType type = 4; */
        if (message.type !== 0)
            writer.tag(4, WireType.Varint).int32(message.type);
        /* auth.v1.SanctionSeverity severity = 5; */
        if (message.severity !== 0)
            writer.tag(5, WireType.Varint).int32(message.severity);
        /* string reason = 6; */
        if (message.reason !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.reason);
        /* string evidence = 7; */
        if (message.evidence !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.evidence);
        /* string issued_by = 8; */
        if (message.issuedBy !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.issuedBy);
        /* google.protobuf.Timestamp issued_at = 9; */
        if (message.issuedAt)
            Timestamp.internalBinaryWrite(message.issuedAt, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp expires_at = 10; */
        if (message.expiresAt)
            Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* auth.v1.SanctionStatus status = 11; */
        if (message.status !== 0)
            writer.tag(11, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.Sanction
 */
export const Sanction = new Sanction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPermissionRequest$Type extends MessageType {
    constructor() {
        super("auth.v1.CheckPermissionRequest", [
            { no: 1, name: "operator_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resource", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "action", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "context", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.operatorId = "";
        message.resource = "";
        message.action = "";
        message.context = {};
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string operator_id */ 1:
                    message.operatorId = reader.string();
                    break;
                case /* string resource */ 2:
                    message.resource = reader.string();
                    break;
                case /* string action */ 3:
                    message.action = reader.string();
                    break;
                case /* map<string, string> context */ 4:
                    this.binaryReadMap4(message.context, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap4(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for auth.v1.CheckPermissionRequest.context");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message, writer, options) {
        /* string operator_id = 1; */
        if (message.operatorId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.operatorId);
        /* string resource = 2; */
        if (message.resource !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resource);
        /* string action = 3; */
        if (message.action !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.action);
        /* map<string, string> context = 4; */
        for (let k of globalThis.Object.keys(message.context))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.context[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.CheckPermissionRequest
 */
export const CheckPermissionRequest = new CheckPermissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPermissionResponse$Type extends MessageType {
    constructor() {
        super("auth.v1.CheckPermissionResponse", [
            { no: 1, name: "allowed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "matched_permissions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.allowed = false;
        message.reason = "";
        message.matchedPermissions = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool allowed */ 1:
                    message.allowed = reader.bool();
                    break;
                case /* string reason */ 2:
                    message.reason = reader.string();
                    break;
                case /* repeated string matched_permissions */ 3:
                    message.matchedPermissions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool allowed = 1; */
        if (message.allowed !== false)
            writer.tag(1, WireType.Varint).bool(message.allowed);
        /* string reason = 2; */
        if (message.reason !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reason);
        /* repeated string matched_permissions = 3; */
        for (let i = 0; i < message.matchedPermissions.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.matchedPermissions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.CheckPermissionResponse
 */
export const CheckPermissionResponse = new CheckPermissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPermissionsRequest$Type extends MessageType {
    constructor() {
        super("auth.v1.CheckPermissionsRequest", [
            { no: 1, name: "operator_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "checks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PermissionCheck }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.operatorId = "";
        message.checks = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string operator_id */ 1:
                    message.operatorId = reader.string();
                    break;
                case /* repeated auth.v1.PermissionCheck checks */ 2:
                    message.checks.push(PermissionCheck.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string operator_id = 1; */
        if (message.operatorId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.operatorId);
        /* repeated auth.v1.PermissionCheck checks = 2; */
        for (let i = 0; i < message.checks.length; i++)
            PermissionCheck.internalBinaryWrite(message.checks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.CheckPermissionsRequest
 */
export const CheckPermissionsRequest = new CheckPermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionCheck$Type extends MessageType {
    constructor() {
        super("auth.v1.PermissionCheck", [
            { no: 1, name: "resource", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.resource = "";
        message.action = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string resource */ 1:
                    message.resource = reader.string();
                    break;
                case /* string action */ 2:
                    message.action = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string resource = 1; */
        if (message.resource !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.resource);
        /* string action = 2; */
        if (message.action !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.PermissionCheck
 */
export const PermissionCheck = new PermissionCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPermissionsResponse$Type extends MessageType {
    constructor() {
        super("auth.v1.CheckPermissionsResponse", [
            { no: 1, name: "all_allowed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PermissionCheckResult }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.allAllowed = false;
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool all_allowed */ 1:
                    message.allAllowed = reader.bool();
                    break;
                case /* repeated auth.v1.PermissionCheckResult results */ 2:
                    message.results.push(PermissionCheckResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool all_allowed = 1; */
        if (message.allAllowed !== false)
            writer.tag(1, WireType.Varint).bool(message.allAllowed);
        /* repeated auth.v1.PermissionCheckResult results = 2; */
        for (let i = 0; i < message.results.length; i++)
            PermissionCheckResult.internalBinaryWrite(message.results[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.CheckPermissionsResponse
 */
export const CheckPermissionsResponse = new CheckPermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionCheckResult$Type extends MessageType {
    constructor() {
        super("auth.v1.PermissionCheckResult", [
            { no: 1, name: "resource", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "allowed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.resource = "";
        message.action = "";
        message.allowed = false;
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string resource */ 1:
                    message.resource = reader.string();
                    break;
                case /* string action */ 2:
                    message.action = reader.string();
                    break;
                case /* bool allowed */ 3:
                    message.allowed = reader.bool();
                    break;
                case /* string reason */ 4:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string resource = 1; */
        if (message.resource !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.resource);
        /* string action = 2; */
        if (message.action !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.action);
        /* bool allowed = 3; */
        if (message.allowed !== false)
            writer.tag(3, WireType.Varint).bool(message.allowed);
        /* string reason = 4; */
        if (message.reason !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.PermissionCheckResult
 */
export const PermissionCheckResult = new PermissionCheckResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOperatorPermissionsRequest$Type extends MessageType {
    constructor() {
        super("auth.v1.GetOperatorPermissionsRequest", [
            { no: 1, name: "operator_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_role_permissions", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.operatorId = "";
        message.includeRolePermissions = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string operator_id */ 1:
                    message.operatorId = reader.string();
                    break;
                case /* bool include_role_permissions */ 2:
                    message.includeRolePermissions = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string operator_id = 1; */
        if (message.operatorId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.operatorId);
        /* bool include_role_permissions = 2; */
        if (message.includeRolePermissions !== false)
            writer.tag(2, WireType.Varint).bool(message.includeRolePermissions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.GetOperatorPermissionsRequest
 */
export const GetOperatorPermissionsRequest = new GetOperatorPermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOperatorPermissionsResponse$Type extends MessageType {
    constructor() {
        super("auth.v1.GetOperatorPermissionsResponse", [
            { no: 1, name: "permissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Permission },
            { no: 2, name: "direct_permissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Permission },
            { no: 3, name: "role_permissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Permission }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.permissions = [];
        message.directPermissions = [];
        message.rolePermissions = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.v1.Permission permissions */ 1:
                    message.permissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated auth.v1.Permission direct_permissions */ 2:
                    message.directPermissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated auth.v1.Permission role_permissions */ 3:
                    message.rolePermissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated auth.v1.Permission permissions = 1; */
        for (let i = 0; i < message.permissions.length; i++)
            Permission.internalBinaryWrite(message.permissions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated auth.v1.Permission direct_permissions = 2; */
        for (let i = 0; i < message.directPermissions.length; i++)
            Permission.internalBinaryWrite(message.directPermissions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated auth.v1.Permission role_permissions = 3; */
        for (let i = 0; i < message.rolePermissions.length; i++)
            Permission.internalBinaryWrite(message.rolePermissions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.GetOperatorPermissionsResponse
 */
export const GetOperatorPermissionsResponse = new GetOperatorPermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRoleRequest$Type extends MessageType {
    constructor() {
        super("auth.v1.GetRoleRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.GetRoleRequest
 */
export const GetRoleRequest = new GetRoleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRoleResponse$Type extends MessageType {
    constructor() {
        super("auth.v1.GetRoleResponse", [
            { no: 1, name: "role", kind: "message", T: () => Role }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* auth.v1.Role role */ 1:
                    message.role = Role.internalBinaryRead(reader, reader.uint32(), options, message.role);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* auth.v1.Role role = 1; */
        if (message.role)
            Role.internalBinaryWrite(message.role, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.GetRoleResponse
 */
export const GetRoleResponse = new GetRoleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRolesByOperatorRequest$Type extends MessageType {
    constructor() {
        super("auth.v1.GetRolesByOperatorRequest", [
            { no: 1, name: "operator_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.operatorId = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string operator_id */ 1:
                    message.operatorId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string operator_id = 1; */
        if (message.operatorId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.operatorId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.GetRolesByOperatorRequest
 */
export const GetRolesByOperatorRequest = new GetRolesByOperatorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRolesByOperatorResponse$Type extends MessageType {
    constructor() {
        super("auth.v1.GetRolesByOperatorResponse", [
            { no: 1, name: "roles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Role }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.roles = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.v1.Role roles */ 1:
                    message.roles.push(Role.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated auth.v1.Role roles = 1; */
        for (let i = 0; i < message.roles.length; i++)
            Role.internalBinaryWrite(message.roles[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.GetRolesByOperatorResponse
 */
export const GetRolesByOperatorResponse = new GetRolesByOperatorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOperatorRequest$Type extends MessageType {
    constructor() {
        super("auth.v1.GetOperatorRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.GetOperatorRequest
 */
export const GetOperatorRequest = new GetOperatorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOperatorResponse$Type extends MessageType {
    constructor() {
        super("auth.v1.GetOperatorResponse", [
            { no: 1, name: "operator", kind: "message", T: () => Operator }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* auth.v1.Operator operator */ 1:
                    message.operator = Operator.internalBinaryRead(reader, reader.uint32(), options, message.operator);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* auth.v1.Operator operator = 1; */
        if (message.operator)
            Operator.internalBinaryWrite(message.operator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.GetOperatorResponse
 */
export const GetOperatorResponse = new GetOperatorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateOperatorRequest$Type extends MessageType {
    constructor() {
        super("auth.v1.ValidateOperatorRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.ValidateOperatorRequest
 */
export const ValidateOperatorRequest = new ValidateOperatorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateOperatorResponse$Type extends MessageType {
    constructor() {
        super("auth.v1.ValidateOperatorResponse", [
            { no: 1, name: "valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["auth.v1.OperatorStatus", OperatorStatus, "OPERATOR_STATUS_"] },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.valid = false;
        message.status = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool valid */ 1:
                    message.valid = reader.bool();
                    break;
                case /* auth.v1.OperatorStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool valid = 1; */
        if (message.valid !== false)
            writer.tag(1, WireType.Varint).bool(message.valid);
        /* auth.v1.OperatorStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.ValidateOperatorResponse
 */
export const ValidateOperatorResponse = new ValidateOperatorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckSanctionRequest$Type extends MessageType {
    constructor() {
        super("auth.v1.CheckSanctionRequest", [
            { no: 1, name: "subject_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subject_type", kind: "enum", T: () => ["auth.v1.SubjectType", SubjectType, "SUBJECT_TYPE_"] },
            { no: 3, name: "sanction_type", kind: "enum", opt: true, T: () => ["auth.v1.SanctionType", SanctionType, "SANCTION_TYPE_"] }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.subjectId = "";
        message.subjectType = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subject_id */ 1:
                    message.subjectId = reader.string();
                    break;
                case /* auth.v1.SubjectType subject_type */ 2:
                    message.subjectType = reader.int32();
                    break;
                case /* optional auth.v1.SanctionType sanction_type */ 3:
                    message.sanctionType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string subject_id = 1; */
        if (message.subjectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subjectId);
        /* auth.v1.SubjectType subject_type = 2; */
        if (message.subjectType !== 0)
            writer.tag(2, WireType.Varint).int32(message.subjectType);
        /* optional auth.v1.SanctionType sanction_type = 3; */
        if (message.sanctionType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.sanctionType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.CheckSanctionRequest
 */
export const CheckSanctionRequest = new CheckSanctionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckSanctionResponse$Type extends MessageType {
    constructor() {
        super("auth.v1.CheckSanctionResponse", [
            { no: 1, name: "is_sanctioned", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "active_sanctions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Sanction },
            { no: 3, name: "highest_severity", kind: "enum", T: () => ["auth.v1.SanctionSeverity", SanctionSeverity, "SANCTION_SEVERITY_"] }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.isSanctioned = false;
        message.activeSanctions = [];
        message.highestSeverity = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_sanctioned */ 1:
                    message.isSanctioned = reader.bool();
                    break;
                case /* repeated auth.v1.Sanction active_sanctions */ 2:
                    message.activeSanctions.push(Sanction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* auth.v1.SanctionSeverity highest_severity */ 3:
                    message.highestSeverity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool is_sanctioned = 1; */
        if (message.isSanctioned !== false)
            writer.tag(1, WireType.Varint).bool(message.isSanctioned);
        /* repeated auth.v1.Sanction active_sanctions = 2; */
        for (let i = 0; i < message.activeSanctions.length; i++)
            Sanction.internalBinaryWrite(message.activeSanctions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* auth.v1.SanctionSeverity highest_severity = 3; */
        if (message.highestSeverity !== 0)
            writer.tag(3, WireType.Varint).int32(message.highestSeverity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.CheckSanctionResponse
 */
export const CheckSanctionResponse = new CheckSanctionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetActiveSanctionsRequest$Type extends MessageType {
    constructor() {
        super("auth.v1.GetActiveSanctionsRequest", [
            { no: 1, name: "subject_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subject_type", kind: "enum", T: () => ["auth.v1.SubjectType", SubjectType, "SUBJECT_TYPE_"] }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.subjectId = "";
        message.subjectType = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subject_id */ 1:
                    message.subjectId = reader.string();
                    break;
                case /* auth.v1.SubjectType subject_type */ 2:
                    message.subjectType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string subject_id = 1; */
        if (message.subjectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subjectId);
        /* auth.v1.SubjectType subject_type = 2; */
        if (message.subjectType !== 0)
            writer.tag(2, WireType.Varint).int32(message.subjectType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.GetActiveSanctionsRequest
 */
export const GetActiveSanctionsRequest = new GetActiveSanctionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetActiveSanctionsResponse$Type extends MessageType {
    constructor() {
        super("auth.v1.GetActiveSanctionsResponse", [
            { no: 1, name: "sanctions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Sanction },
            { no: 2, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.sanctions = [];
        message.totalCount = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.v1.Sanction sanctions */ 1:
                    message.sanctions.push(Sanction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_count */ 2:
                    message.totalCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated auth.v1.Sanction sanctions = 1; */
        for (let i = 0; i < message.sanctions.length; i++)
            Sanction.internalBinaryWrite(message.sanctions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.v1.GetActiveSanctionsResponse
 */
export const GetActiveSanctionsResponse = new GetActiveSanctionsResponse$Type();
/**
 * @generated ServiceType for protobuf service auth.v1.AuthService
 */
export const AuthService = new ServiceType("auth.v1.AuthService", [
    { name: "CheckPermission", options: {}, I: CheckPermissionRequest, O: CheckPermissionResponse },
    { name: "CheckPermissions", options: {}, I: CheckPermissionsRequest, O: CheckPermissionsResponse },
    { name: "GetOperatorPermissions", options: {}, I: GetOperatorPermissionsRequest, O: GetOperatorPermissionsResponse },
    { name: "GetRole", options: {}, I: GetRoleRequest, O: GetRoleResponse },
    { name: "GetRolesByOperator", options: {}, I: GetRolesByOperatorRequest, O: GetRolesByOperatorResponse },
    { name: "GetOperator", options: {}, I: GetOperatorRequest, O: GetOperatorResponse },
    { name: "ValidateOperator", options: {}, I: ValidateOperatorRequest, O: ValidateOperatorResponse },
    { name: "CheckSanction", options: {}, I: CheckSanctionRequest, O: CheckSanctionResponse },
    { name: "GetActiveSanctions", options: {}, I: GetActiveSanctionsRequest, O: GetActiveSanctionsResponse }
]);
