// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies,ts_nocheck,add_pb_suffix,output_javascript
// @generated from protobuf file "authorization/v1/authorization.proto" (package "authorization.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies,ts_nocheck,add_pb_suffix,output_javascript
// @generated from protobuf file "authorization/v1/authorization.proto" (package "authorization.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// @generated message type with reflection information, may provide speed optimized methods
class TupleKey$Type extends MessageType {
    constructor() {
        super("authorization.v1.TupleKey", [
            { no: 1, name: "user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "object", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.user = "";
        message.relation = "";
        message.object = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user */ 1:
                    message.user = reader.string();
                    break;
                case /* string relation */ 2:
                    message.relation = reader.string();
                    break;
                case /* string object */ 3:
                    message.object = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string user = 1; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string relation = 2; */
        if (message.relation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        /* string object = 3; */
        if (message.object !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.object);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.TupleKey
 */
export const TupleKey = new TupleKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResolutionTrace$Type extends MessageType {
    constructor() {
        super("authorization.v1.ResolutionTrace", [
            { no: 1, name: "node_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "result", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ResolutionTrace },
            { no: 4, name: "duration_us", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "context", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.nodeType = "";
        message.result = false;
        message.children = [];
        message.durationUs = "0";
        message.context = {};
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string node_type */ 1:
                    message.nodeType = reader.string();
                    break;
                case /* bool result */ 2:
                    message.result = reader.bool();
                    break;
                case /* repeated authorization.v1.ResolutionTrace children */ 3:
                    message.children.push(ResolutionTrace.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 duration_us */ 4:
                    message.durationUs = reader.int64().toString();
                    break;
                case /* map<string, string> context */ 5:
                    this.binaryReadMap5(message.context, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap5(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for authorization.v1.ResolutionTrace.context");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message, writer, options) {
        /* string node_type = 1; */
        if (message.nodeType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nodeType);
        /* bool result = 2; */
        if (message.result !== false)
            writer.tag(2, WireType.Varint).bool(message.result);
        /* repeated authorization.v1.ResolutionTrace children = 3; */
        for (let i = 0; i < message.children.length; i++)
            ResolutionTrace.internalBinaryWrite(message.children[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 duration_us = 4; */
        if (message.durationUs !== "0")
            writer.tag(4, WireType.Varint).int64(message.durationUs);
        /* map<string, string> context = 5; */
        for (let k of globalThis.Object.keys(message.context))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.context[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ResolutionTrace
 */
export const ResolutionTrace = new ResolutionTrace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.CheckRequest", [
            { no: 1, name: "user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "object", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "contextual_tuples", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TupleKey },
            { no: 5, name: "trace", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "consistency_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.user = "";
        message.relation = "";
        message.object = "";
        message.contextualTuples = [];
        message.trace = false;
        message.consistencyToken = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user */ 1:
                    message.user = reader.string();
                    break;
                case /* string relation */ 2:
                    message.relation = reader.string();
                    break;
                case /* string object */ 3:
                    message.object = reader.string();
                    break;
                case /* repeated authorization.v1.TupleKey contextual_tuples */ 4:
                    message.contextualTuples.push(TupleKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool trace */ 5:
                    message.trace = reader.bool();
                    break;
                case /* string consistency_token */ 6:
                    message.consistencyToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string user = 1; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string relation = 2; */
        if (message.relation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        /* string object = 3; */
        if (message.object !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.object);
        /* repeated authorization.v1.TupleKey contextual_tuples = 4; */
        for (let i = 0; i < message.contextualTuples.length; i++)
            TupleKey.internalBinaryWrite(message.contextualTuples[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool trace = 5; */
        if (message.trace !== false)
            writer.tag(5, WireType.Varint).bool(message.trace);
        /* string consistency_token = 6; */
        if (message.consistencyToken !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.consistencyToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.CheckRequest
 */
export const CheckRequest = new CheckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.CheckResponse", [
            { no: 1, name: "allowed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "resolution", kind: "message", T: () => ResolutionTrace },
            { no: 3, name: "consistency_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.allowed = false;
        message.consistencyToken = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool allowed */ 1:
                    message.allowed = reader.bool();
                    break;
                case /* authorization.v1.ResolutionTrace resolution */ 2:
                    message.resolution = ResolutionTrace.internalBinaryRead(reader, reader.uint32(), options, message.resolution);
                    break;
                case /* string consistency_token */ 3:
                    message.consistencyToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool allowed = 1; */
        if (message.allowed !== false)
            writer.tag(1, WireType.Varint).bool(message.allowed);
        /* authorization.v1.ResolutionTrace resolution = 2; */
        if (message.resolution)
            ResolutionTrace.internalBinaryWrite(message.resolution, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string consistency_token = 3; */
        if (message.consistencyToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.consistencyToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.CheckResponse
 */
export const CheckResponse = new CheckResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchCheckRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.BatchCheckRequest", [
            { no: 1, name: "checks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CheckRequestItem }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.checks = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authorization.v1.CheckRequestItem checks */ 1:
                    message.checks.push(CheckRequestItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated authorization.v1.CheckRequestItem checks = 1; */
        for (let i = 0; i < message.checks.length; i++)
            CheckRequestItem.internalBinaryWrite(message.checks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.BatchCheckRequest
 */
export const BatchCheckRequest = new BatchCheckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckRequestItem$Type extends MessageType {
    constructor() {
        super("authorization.v1.CheckRequestItem", [
            { no: 1, name: "user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "object", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.user = "";
        message.relation = "";
        message.object = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user */ 1:
                    message.user = reader.string();
                    break;
                case /* string relation */ 2:
                    message.relation = reader.string();
                    break;
                case /* string object */ 3:
                    message.object = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string user = 1; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string relation = 2; */
        if (message.relation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        /* string object = 3; */
        if (message.object !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.object);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.CheckRequestItem
 */
export const CheckRequestItem = new CheckRequestItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchCheckResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.BatchCheckResponse", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CheckResponseItem }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authorization.v1.CheckResponseItem results */ 1:
                    message.results.push(CheckResponseItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated authorization.v1.CheckResponseItem results = 1; */
        for (let i = 0; i < message.results.length; i++)
            CheckResponseItem.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.BatchCheckResponse
 */
export const BatchCheckResponse = new BatchCheckResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckResponseItem$Type extends MessageType {
    constructor() {
        super("authorization.v1.CheckResponseItem", [
            { no: 1, name: "allowed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.allowed = false;
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool allowed */ 1:
                    message.allowed = reader.bool();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool allowed = 1; */
        if (message.allowed !== false)
            writer.tag(1, WireType.Varint).bool(message.allowed);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.CheckResponseItem
 */
export const CheckResponseItem = new CheckResponseItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.WriteRequest", [
            { no: 1, name: "writes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TupleKey },
            { no: 2, name: "deletes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TupleKey }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.writes = [];
        message.deletes = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authorization.v1.TupleKey writes */ 1:
                    message.writes.push(TupleKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated authorization.v1.TupleKey deletes */ 2:
                    message.deletes.push(TupleKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated authorization.v1.TupleKey writes = 1; */
        for (let i = 0; i < message.writes.length; i++)
            TupleKey.internalBinaryWrite(message.writes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authorization.v1.TupleKey deletes = 2; */
        for (let i = 0; i < message.deletes.length; i++)
            TupleKey.internalBinaryWrite(message.deletes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.WriteRequest
 */
export const WriteRequest = new WriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.WriteResponse", [
            { no: 1, name: "consistency_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "written_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "deleted_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.consistencyToken = "";
        message.writtenCount = 0;
        message.deletedCount = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string consistency_token */ 1:
                    message.consistencyToken = reader.string();
                    break;
                case /* int32 written_count */ 2:
                    message.writtenCount = reader.int32();
                    break;
                case /* int32 deleted_count */ 3:
                    message.deletedCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string consistency_token = 1; */
        if (message.consistencyToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.consistencyToken);
        /* int32 written_count = 2; */
        if (message.writtenCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.writtenCount);
        /* int32 deleted_count = 3; */
        if (message.deletedCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.deletedCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.WriteResponse
 */
export const WriteResponse = new WriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.ReadRequest", [
            { no: 1, name: "user", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relation", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "object", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.pageSize = 0;
        message.pageToken = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string user */ 1:
                    message.user = reader.string();
                    break;
                case /* optional string relation */ 2:
                    message.relation = reader.string();
                    break;
                case /* optional string object */ 3:
                    message.object = reader.string();
                    break;
                case /* int32 page_size */ 4:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 5:
                    message.pageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string user = 1; */
        if (message.user !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* optional string relation = 2; */
        if (message.relation !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        /* optional string object = 3; */
        if (message.object !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.object);
        /* int32 page_size = 4; */
        if (message.pageSize !== 0)
            writer.tag(4, WireType.Varint).int32(message.pageSize);
        /* string page_token = 5; */
        if (message.pageToken !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ReadRequest
 */
export const ReadRequest = new ReadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.ReadResponse", [
            { no: 1, name: "tuples", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TupleKey },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.tuples = [];
        message.nextPageToken = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authorization.v1.TupleKey tuples */ 1:
                    message.tuples.push(TupleKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated authorization.v1.TupleKey tuples = 1; */
        for (let i = 0; i < message.tuples.length; i++)
            TupleKey.internalBinaryWrite(message.tuples[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ReadResponse
 */
export const ReadResponse = new ReadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListObjectsRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.ListObjectsRequest", [
            { no: 1, name: "user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.user = "";
        message.relation = "";
        message.type = "";
        message.pageSize = 0;
        message.pageToken = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user */ 1:
                    message.user = reader.string();
                    break;
                case /* string relation */ 2:
                    message.relation = reader.string();
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                case /* int32 page_size */ 4:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 5:
                    message.pageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string user = 1; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string relation = 2; */
        if (message.relation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* int32 page_size = 4; */
        if (message.pageSize !== 0)
            writer.tag(4, WireType.Varint).int32(message.pageSize);
        /* string page_token = 5; */
        if (message.pageToken !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ListObjectsRequest
 */
export const ListObjectsRequest = new ListObjectsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListObjectsResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.ListObjectsResponse", [
            { no: 1, name: "objects", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.objects = [];
        message.nextPageToken = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string objects */ 1:
                    message.objects.push(reader.string());
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated string objects = 1; */
        for (let i = 0; i < message.objects.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.objects[i]);
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ListObjectsResponse
 */
export const ListObjectsResponse = new ListObjectsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUsersRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.ListUsersRequest", [
            { no: 1, name: "object", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.object = "";
        message.relation = "";
        message.userTypes = [];
        message.pageSize = 0;
        message.pageToken = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object */ 1:
                    message.object = reader.string();
                    break;
                case /* string relation */ 2:
                    message.relation = reader.string();
                    break;
                case /* repeated string user_types */ 3:
                    message.userTypes.push(reader.string());
                    break;
                case /* int32 page_size */ 4:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 5:
                    message.pageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object = 1; */
        if (message.object !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.object);
        /* string relation = 2; */
        if (message.relation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        /* repeated string user_types = 3; */
        for (let i = 0; i < message.userTypes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.userTypes[i]);
        /* int32 page_size = 4; */
        if (message.pageSize !== 0)
            writer.tag(4, WireType.Varint).int32(message.pageSize);
        /* string page_token = 5; */
        if (message.pageToken !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ListUsersRequest
 */
export const ListUsersRequest = new ListUsersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUsersResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.ListUsersResponse", [
            { no: 1, name: "users", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.users = [];
        message.nextPageToken = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string users */ 1:
                    message.users.push(reader.string());
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated string users = 1; */
        for (let i = 0; i < message.users.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.users[i]);
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ListUsersResponse
 */
export const ListUsersResponse = new ListUsersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.ExpandRequest", [
            { no: 1, name: "object", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.object = "";
        message.relation = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object */ 1:
                    message.object = reader.string();
                    break;
                case /* string relation */ 2:
                    message.relation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object = 1; */
        if (message.object !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.object);
        /* string relation = 2; */
        if (message.relation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ExpandRequest
 */
export const ExpandRequest = new ExpandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.ExpandResponse", [
            { no: 1, name: "tree", kind: "message", T: () => UsersetTree }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authorization.v1.UsersetTree tree */ 1:
                    message.tree = UsersetTree.internalBinaryRead(reader, reader.uint32(), options, message.tree);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authorization.v1.UsersetTree tree = 1; */
        if (message.tree)
            UsersetTree.internalBinaryWrite(message.tree, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ExpandResponse
 */
export const ExpandResponse = new ExpandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UsersetTree$Type extends MessageType {
    constructor() {
        super("authorization.v1.UsersetTree", [
            { no: 1, name: "leaf", kind: "message", oneof: "node", T: () => LeafNode },
            { no: 2, name: "computed", kind: "message", oneof: "node", T: () => ComputedNode },
            { no: 3, name: "tuple_to_userset", kind: "message", oneof: "node", T: () => TupleToUsersetNode },
            { no: 4, name: "union", kind: "message", oneof: "node", T: () => UnionNode },
            { no: 5, name: "intersection", kind: "message", oneof: "node", T: () => IntersectionNode },
            { no: 6, name: "exclusion", kind: "message", oneof: "node", T: () => ExclusionNode }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.node = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authorization.v1.LeafNode leaf */ 1:
                    message.node = {
                        oneofKind: "leaf",
                        leaf: LeafNode.internalBinaryRead(reader, reader.uint32(), options, message.node.leaf)
                    };
                    break;
                case /* authorization.v1.ComputedNode computed */ 2:
                    message.node = {
                        oneofKind: "computed",
                        computed: ComputedNode.internalBinaryRead(reader, reader.uint32(), options, message.node.computed)
                    };
                    break;
                case /* authorization.v1.TupleToUsersetNode tuple_to_userset */ 3:
                    message.node = {
                        oneofKind: "tupleToUserset",
                        tupleToUserset: TupleToUsersetNode.internalBinaryRead(reader, reader.uint32(), options, message.node.tupleToUserset)
                    };
                    break;
                case /* authorization.v1.UnionNode union */ 4:
                    message.node = {
                        oneofKind: "union",
                        union: UnionNode.internalBinaryRead(reader, reader.uint32(), options, message.node.union)
                    };
                    break;
                case /* authorization.v1.IntersectionNode intersection */ 5:
                    message.node = {
                        oneofKind: "intersection",
                        intersection: IntersectionNode.internalBinaryRead(reader, reader.uint32(), options, message.node.intersection)
                    };
                    break;
                case /* authorization.v1.ExclusionNode exclusion */ 6:
                    message.node = {
                        oneofKind: "exclusion",
                        exclusion: ExclusionNode.internalBinaryRead(reader, reader.uint32(), options, message.node.exclusion)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authorization.v1.LeafNode leaf = 1; */
        if (message.node.oneofKind === "leaf")
            LeafNode.internalBinaryWrite(message.node.leaf, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authorization.v1.ComputedNode computed = 2; */
        if (message.node.oneofKind === "computed")
            ComputedNode.internalBinaryWrite(message.node.computed, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* authorization.v1.TupleToUsersetNode tuple_to_userset = 3; */
        if (message.node.oneofKind === "tupleToUserset")
            TupleToUsersetNode.internalBinaryWrite(message.node.tupleToUserset, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* authorization.v1.UnionNode union = 4; */
        if (message.node.oneofKind === "union")
            UnionNode.internalBinaryWrite(message.node.union, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* authorization.v1.IntersectionNode intersection = 5; */
        if (message.node.oneofKind === "intersection")
            IntersectionNode.internalBinaryWrite(message.node.intersection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* authorization.v1.ExclusionNode exclusion = 6; */
        if (message.node.oneofKind === "exclusion")
            ExclusionNode.internalBinaryWrite(message.node.exclusion, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.UsersetTree
 */
export const UsersetTree = new UsersetTree$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeafNode$Type extends MessageType {
    constructor() {
        super("authorization.v1.LeafNode", [
            { no: 1, name: "users", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.users = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string users */ 1:
                    message.users.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated string users = 1; */
        for (let i = 0; i < message.users.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.users[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.LeafNode
 */
export const LeafNode = new LeafNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComputedNode$Type extends MessageType {
    constructor() {
        super("authorization.v1.ComputedNode", [
            { no: 1, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UsersetTree }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.relation = "";
        message.children = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string relation */ 1:
                    message.relation = reader.string();
                    break;
                case /* repeated authorization.v1.UsersetTree children */ 2:
                    message.children.push(UsersetTree.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string relation = 1; */
        if (message.relation !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.relation);
        /* repeated authorization.v1.UsersetTree children = 2; */
        for (let i = 0; i < message.children.length; i++)
            UsersetTree.internalBinaryWrite(message.children[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ComputedNode
 */
export const ComputedNode = new ComputedNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TupleToUsersetNode$Type extends MessageType {
    constructor() {
        super("authorization.v1.TupleToUsersetNode", [
            { no: 1, name: "tupleset_relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "computed_relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UsersetTree }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.tuplesetRelation = "";
        message.computedRelation = "";
        message.children = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tupleset_relation */ 1:
                    message.tuplesetRelation = reader.string();
                    break;
                case /* string computed_relation */ 2:
                    message.computedRelation = reader.string();
                    break;
                case /* repeated authorization.v1.UsersetTree children */ 3:
                    message.children.push(UsersetTree.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string tupleset_relation = 1; */
        if (message.tuplesetRelation !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tuplesetRelation);
        /* string computed_relation = 2; */
        if (message.computedRelation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.computedRelation);
        /* repeated authorization.v1.UsersetTree children = 3; */
        for (let i = 0; i < message.children.length; i++)
            UsersetTree.internalBinaryWrite(message.children[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.TupleToUsersetNode
 */
export const TupleToUsersetNode = new TupleToUsersetNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnionNode$Type extends MessageType {
    constructor() {
        super("authorization.v1.UnionNode", [
            { no: 1, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UsersetTree }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.children = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authorization.v1.UsersetTree children */ 1:
                    message.children.push(UsersetTree.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated authorization.v1.UsersetTree children = 1; */
        for (let i = 0; i < message.children.length; i++)
            UsersetTree.internalBinaryWrite(message.children[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.UnionNode
 */
export const UnionNode = new UnionNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntersectionNode$Type extends MessageType {
    constructor() {
        super("authorization.v1.IntersectionNode", [
            { no: 1, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UsersetTree }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.children = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authorization.v1.UsersetTree children */ 1:
                    message.children.push(UsersetTree.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated authorization.v1.UsersetTree children = 1; */
        for (let i = 0; i < message.children.length; i++)
            UsersetTree.internalBinaryWrite(message.children[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.IntersectionNode
 */
export const IntersectionNode = new IntersectionNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExclusionNode$Type extends MessageType {
    constructor() {
        super("authorization.v1.ExclusionNode", [
            { no: 1, name: "base", kind: "message", T: () => UsersetTree },
            { no: 2, name: "subtract", kind: "message", T: () => UsersetTree }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authorization.v1.UsersetTree base */ 1:
                    message.base = UsersetTree.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                case /* authorization.v1.UsersetTree subtract */ 2:
                    message.subtract = UsersetTree.internalBinaryRead(reader, reader.uint32(), options, message.subtract);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authorization.v1.UsersetTree base = 1; */
        if (message.base)
            UsersetTree.internalBinaryWrite(message.base, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authorization.v1.UsersetTree subtract = 2; */
        if (message.subtract)
            UsersetTree.internalBinaryWrite(message.subtract, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ExclusionNode
 */
export const ExclusionNode = new ExclusionNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteModelRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.WriteModelRequest", [
            { no: 1, name: "dsl_source", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "activate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "notes", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.dslSource = "";
        message.activate = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string dsl_source */ 1:
                    message.dslSource = reader.string();
                    break;
                case /* bool activate */ 2:
                    message.activate = reader.bool();
                    break;
                case /* optional string notes */ 3:
                    message.notes = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string dsl_source = 1; */
        if (message.dslSource !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dslSource);
        /* bool activate = 2; */
        if (message.activate !== false)
            writer.tag(2, WireType.Varint).bool(message.activate);
        /* optional string notes = 3; */
        if (message.notes !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.notes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.WriteModelRequest
 */
export const WriteModelRequest = new WriteModelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteModelResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.WriteModelResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "model_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "errors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ModelValidationError },
            { no: 5, name: "warnings", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ModelValidationWarning }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.success = false;
        message.modelId = "";
        message.versionId = "";
        message.errors = [];
        message.warnings = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string model_id */ 2:
                    message.modelId = reader.string();
                    break;
                case /* string version_id */ 3:
                    message.versionId = reader.string();
                    break;
                case /* repeated authorization.v1.ModelValidationError errors */ 4:
                    message.errors.push(ModelValidationError.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated authorization.v1.ModelValidationWarning warnings */ 5:
                    message.warnings.push(ModelValidationWarning.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string model_id = 2; */
        if (message.modelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.modelId);
        /* string version_id = 3; */
        if (message.versionId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.versionId);
        /* repeated authorization.v1.ModelValidationError errors = 4; */
        for (let i = 0; i < message.errors.length; i++)
            ModelValidationError.internalBinaryWrite(message.errors[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated authorization.v1.ModelValidationWarning warnings = 5; */
        for (let i = 0; i < message.warnings.length; i++)
            ModelValidationWarning.internalBinaryWrite(message.warnings[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.WriteModelResponse
 */
export const WriteModelResponse = new WriteModelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModelValidationError$Type extends MessageType {
    constructor() {
        super("authorization.v1.ModelValidationError", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "line", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "column", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.relation = "";
        message.message = "";
        message.line = 0;
        message.column = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string relation */ 2:
                    message.relation = reader.string();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* int32 line */ 4:
                    message.line = reader.int32();
                    break;
                case /* int32 column */ 5:
                    message.column = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string relation = 2; */
        if (message.relation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* int32 line = 4; */
        if (message.line !== 0)
            writer.tag(4, WireType.Varint).int32(message.line);
        /* int32 column = 5; */
        if (message.column !== 0)
            writer.tag(5, WireType.Varint).int32(message.column);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ModelValidationError
 */
export const ModelValidationError = new ModelValidationError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModelValidationWarning$Type extends MessageType {
    constructor() {
        super("authorization.v1.ModelValidationWarning", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.relation = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string relation */ 2:
                    message.relation = reader.string();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string relation = 2; */
        if (message.relation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ModelValidationWarning
 */
export const ModelValidationWarning = new ModelValidationWarning$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadModelRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.ReadModelRequest", [
            { no: 1, name: "version_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string version_id */ 1:
                    message.versionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string version_id = 1; */
        if (message.versionId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.versionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ReadModelRequest
 */
export const ReadModelRequest = new ReadModelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadModelResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.ReadModelResponse", [
            { no: 1, name: "dsl_source", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "model_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.dslSource = "";
        message.modelId = "";
        message.versionId = "";
        message.isActive = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string dsl_source */ 1:
                    message.dslSource = reader.string();
                    break;
                case /* string model_id */ 2:
                    message.modelId = reader.string();
                    break;
                case /* string version_id */ 3:
                    message.versionId = reader.string();
                    break;
                case /* bool is_active */ 4:
                    message.isActive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string dsl_source = 1; */
        if (message.dslSource !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dslSource);
        /* string model_id = 2; */
        if (message.modelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.modelId);
        /* string version_id = 3; */
        if (message.versionId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.versionId);
        /* bool is_active = 4; */
        if (message.isActive !== false)
            writer.tag(4, WireType.Varint).bool(message.isActive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ReadModelResponse
 */
export const ReadModelResponse = new ReadModelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivateModelRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.ActivateModelRequest", [
            { no: 1, name: "model_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.modelId = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string model_id */ 1:
                    message.modelId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string model_id = 1; */
        if (message.modelId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.modelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ActivateModelRequest
 */
export const ActivateModelRequest = new ActivateModelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivateModelResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.ActivateModelResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ActivateModelResponse
 */
export const ActivateModelResponse = new ActivateModelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListModelsRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.ListModelsRequest", [
            { no: 1, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.pageSize = 0;
        message.pageToken = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_size */ 1:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 page_size = 1; */
        if (message.pageSize !== 0)
            writer.tag(1, WireType.Varint).int32(message.pageSize);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ListModelsRequest
 */
export const ListModelsRequest = new ListModelsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListModelsResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.ListModelsResponse", [
            { no: 1, name: "models", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ModelSummary },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.models = [];
        message.nextPageToken = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authorization.v1.ModelSummary models */ 1:
                    message.models.push(ModelSummary.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated authorization.v1.ModelSummary models = 1; */
        for (let i = 0; i < message.models.length; i++)
            ModelSummary.internalBinaryWrite(message.models[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ListModelsResponse
 */
export const ListModelsResponse = new ListModelsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModelSummary$Type extends MessageType {
    constructor() {
        super("authorization.v1.ModelSummary", [
            { no: 1, name: "model_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "notes", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.modelId = "";
        message.versionId = "";
        message.isActive = false;
        message.createdAt = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string model_id */ 1:
                    message.modelId = reader.string();
                    break;
                case /* string version_id */ 2:
                    message.versionId = reader.string();
                    break;
                case /* bool is_active */ 3:
                    message.isActive = reader.bool();
                    break;
                case /* string created_at */ 4:
                    message.createdAt = reader.string();
                    break;
                case /* optional string notes */ 5:
                    message.notes = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string model_id = 1; */
        if (message.modelId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.modelId);
        /* string version_id = 2; */
        if (message.versionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.versionId);
        /* bool is_active = 3; */
        if (message.isActive !== false)
            writer.tag(3, WireType.Varint).bool(message.isActive);
        /* string created_at = 4; */
        if (message.createdAt !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.createdAt);
        /* optional string notes = 5; */
        if (message.notes !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.notes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ModelSummary
 */
export const ModelSummary = new ModelSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTeamRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.GetTeamRequest", [
            { no: 1, name: "team_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.teamId = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string team_id */ 1:
                    message.teamId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string team_id = 1; */
        if (message.teamId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.teamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.GetTeamRequest
 */
export const GetTeamRequest = new GetTeamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTeamResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.GetTeamResponse", [
            { no: 1, name: "team", kind: "message", T: () => Team }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authorization.v1.Team team */ 1:
                    message.team = Team.internalBinaryRead(reader, reader.uint32(), options, message.team);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authorization.v1.Team team = 1; */
        if (message.team)
            Team.internalBinaryWrite(message.team, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.GetTeamResponse
 */
export const GetTeamResponse = new GetTeamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTeamsRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.ListTeamsRequest", [
            { no: 1, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "search", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.page = 0;
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page */ 1:
                    message.page = reader.int32();
                    break;
                case /* int32 limit */ 2:
                    message.limit = reader.int32();
                    break;
                case /* optional string search */ 3:
                    message.search = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 page = 1; */
        if (message.page !== 0)
            writer.tag(1, WireType.Varint).int32(message.page);
        /* int32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).int32(message.limit);
        /* optional string search = 3; */
        if (message.search !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.search);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ListTeamsRequest
 */
export const ListTeamsRequest = new ListTeamsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTeamsResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.ListTeamsResponse", [
            { no: 1, name: "teams", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Team },
            { no: 2, name: "total", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "total_pages", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.teams = [];
        message.total = 0;
        message.page = 0;
        message.totalPages = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authorization.v1.Team teams */ 1:
                    message.teams.push(Team.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total */ 2:
                    message.total = reader.int32();
                    break;
                case /* int32 page */ 3:
                    message.page = reader.int32();
                    break;
                case /* int32 total_pages */ 4:
                    message.totalPages = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated authorization.v1.Team teams = 1; */
        for (let i = 0; i < message.teams.length; i++)
            Team.internalBinaryWrite(message.teams[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total = 2; */
        if (message.total !== 0)
            writer.tag(2, WireType.Varint).int32(message.total);
        /* int32 page = 3; */
        if (message.page !== 0)
            writer.tag(3, WireType.Varint).int32(message.page);
        /* int32 total_pages = 4; */
        if (message.totalPages !== 0)
            writer.tag(4, WireType.Varint).int32(message.totalPages);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.ListTeamsResponse
 */
export const ListTeamsResponse = new ListTeamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateTeamRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.CreateTeamRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "service_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.name = "";
        message.createdBy = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string description */ 2:
                    message.description = reader.string();
                    break;
                case /* optional string service_id */ 3:
                    message.serviceId = reader.string();
                    break;
                case /* string created_by */ 4:
                    message.createdBy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string description = 2; */
        if (message.description !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* optional string service_id = 3; */
        if (message.serviceId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.serviceId);
        /* string created_by = 4; */
        if (message.createdBy !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.createdBy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.CreateTeamRequest
 */
export const CreateTeamRequest = new CreateTeamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateTeamResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.CreateTeamResponse", [
            { no: 1, name: "team", kind: "message", T: () => Team }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authorization.v1.Team team */ 1:
                    message.team = Team.internalBinaryRead(reader, reader.uint32(), options, message.team);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authorization.v1.Team team = 1; */
        if (message.team)
            Team.internalBinaryWrite(message.team, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.CreateTeamResponse
 */
export const CreateTeamResponse = new CreateTeamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTeamRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.UpdateTeamRequest", [
            { no: 1, name: "team_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.teamId = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string team_id */ 1:
                    message.teamId = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string description */ 3:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string team_id = 1; */
        if (message.teamId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.teamId);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string description = 3; */
        if (message.description !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.UpdateTeamRequest
 */
export const UpdateTeamRequest = new UpdateTeamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTeamResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.UpdateTeamResponse", [
            { no: 1, name: "team", kind: "message", T: () => Team }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authorization.v1.Team team */ 1:
                    message.team = Team.internalBinaryRead(reader, reader.uint32(), options, message.team);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authorization.v1.Team team = 1; */
        if (message.team)
            Team.internalBinaryWrite(message.team, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.UpdateTeamResponse
 */
export const UpdateTeamResponse = new UpdateTeamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTeamRequest$Type extends MessageType {
    constructor() {
        super("authorization.v1.DeleteTeamRequest", [
            { no: 1, name: "team_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.teamId = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string team_id */ 1:
                    message.teamId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string team_id = 1; */
        if (message.teamId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.teamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.DeleteTeamRequest
 */
export const DeleteTeamRequest = new DeleteTeamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTeamResponse$Type extends MessageType {
    constructor() {
        super("authorization.v1.DeleteTeamResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.DeleteTeamResponse
 */
export const DeleteTeamResponse = new DeleteTeamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Team$Type extends MessageType {
    constructor() {
        super("authorization.v1.Team", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "service_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.name = "";
        message.displayName = "";
        message.createdBy = "";
        message.createdAt = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                case /* optional string service_id */ 4:
                    message.serviceId = reader.string();
                    break;
                case /* optional string description */ 5:
                    message.description = reader.string();
                    break;
                case /* string created_by */ 6:
                    message.createdBy = reader.string();
                    break;
                case /* string created_at */ 7:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 8:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string display_name = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        /* optional string service_id = 4; */
        if (message.serviceId !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.serviceId);
        /* optional string description = 5; */
        if (message.description !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.description);
        /* string created_by = 6; */
        if (message.createdBy !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.createdBy);
        /* string created_at = 7; */
        if (message.createdAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 8; */
        if (message.updatedAt !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authorization.v1.Team
 */
export const Team = new Team$Type();
/**
 * @generated ServiceType for protobuf service authorization.v1.AuthorizationService
 */
export const AuthorizationService = new ServiceType("authorization.v1.AuthorizationService", [
    { name: "Check", options: {}, I: CheckRequest, O: CheckResponse },
    { name: "BatchCheck", options: {}, I: BatchCheckRequest, O: BatchCheckResponse },
    { name: "Write", options: {}, I: WriteRequest, O: WriteResponse },
    { name: "Read", options: {}, I: ReadRequest, O: ReadResponse },
    { name: "ListObjects", options: {}, I: ListObjectsRequest, O: ListObjectsResponse },
    { name: "ListUsers", options: {}, I: ListUsersRequest, O: ListUsersResponse },
    { name: "Expand", options: {}, I: ExpandRequest, O: ExpandResponse },
    { name: "WriteModel", options: {}, I: WriteModelRequest, O: WriteModelResponse },
    { name: "ReadModel", options: {}, I: ReadModelRequest, O: ReadModelResponse },
    { name: "ListModels", options: {}, I: ListModelsRequest, O: ListModelsResponse },
    { name: "ActivateModel", options: {}, I: ActivateModelRequest, O: ActivateModelResponse },
    { name: "GetTeam", options: {}, I: GetTeamRequest, O: GetTeamResponse },
    { name: "ListTeams", options: {}, I: ListTeamsRequest, O: ListTeamsResponse },
    { name: "CreateTeam", options: {}, I: CreateTeamRequest, O: CreateTeamResponse },
    { name: "UpdateTeam", options: {}, I: UpdateTeamRequest, O: UpdateTeamResponse },
    { name: "DeleteTeam", options: {}, I: DeleteTeamRequest, O: DeleteTeamResponse }
]);
