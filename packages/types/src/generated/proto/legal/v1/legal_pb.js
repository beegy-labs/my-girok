// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies,ts_nocheck,add_pb_suffix,output_javascript
// @generated from protobuf file "legal/v1/legal.proto" (package "legal.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies,ts_nocheck,add_pb_suffix,output_javascript
// @generated from protobuf file "legal/v1/legal.proto" (package "legal.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../google/protobuf/timestamp_pb.js";
/**
 * ConsentType categorizes the consent
 *
 * @generated from protobuf enum legal.v1.ConsentType
 */
export var ConsentType;
(function (ConsentType) {
    /**
     * @generated from protobuf enum value: CONSENT_TYPE_UNSPECIFIED = 0;
     */
    ConsentType[ConsentType["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: CONSENT_TYPE_TERMS_OF_SERVICE = 1;
     */
    ConsentType[ConsentType["TERMS_OF_SERVICE"] = 1] = "TERMS_OF_SERVICE";
    /**
     * @generated from protobuf enum value: CONSENT_TYPE_PRIVACY_POLICY = 2;
     */
    ConsentType[ConsentType["PRIVACY_POLICY"] = 2] = "PRIVACY_POLICY";
    /**
     * @generated from protobuf enum value: CONSENT_TYPE_MARKETING = 3;
     */
    ConsentType[ConsentType["MARKETING"] = 3] = "MARKETING";
    /**
     * @generated from protobuf enum value: CONSENT_TYPE_ANALYTICS = 4;
     */
    ConsentType[ConsentType["ANALYTICS"] = 4] = "ANALYTICS";
    /**
     * @generated from protobuf enum value: CONSENT_TYPE_THIRD_PARTY_SHARING = 5;
     */
    ConsentType[ConsentType["THIRD_PARTY_SHARING"] = 5] = "THIRD_PARTY_SHARING";
    /**
     * @generated from protobuf enum value: CONSENT_TYPE_AGE_VERIFICATION = 6;
     */
    ConsentType[ConsentType["AGE_VERIFICATION"] = 6] = "AGE_VERIFICATION";
    /**
     * @generated from protobuf enum value: CONSENT_TYPE_PARENTAL_CONSENT = 7;
     */
    ConsentType[ConsentType["PARENTAL_CONSENT"] = 7] = "PARENTAL_CONSENT";
})(ConsentType || (ConsentType = {}));
/**
 * ConsentStatus represents the state of a consent
 *
 * @generated from protobuf enum legal.v1.ConsentStatus
 */
export var ConsentStatus;
(function (ConsentStatus) {
    /**
     * @generated from protobuf enum value: CONSENT_STATUS_UNSPECIFIED = 0;
     */
    ConsentStatus[ConsentStatus["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: CONSENT_STATUS_ACTIVE = 1;
     */
    ConsentStatus[ConsentStatus["ACTIVE"] = 1] = "ACTIVE";
    /**
     * @generated from protobuf enum value: CONSENT_STATUS_EXPIRED = 2;
     */
    ConsentStatus[ConsentStatus["EXPIRED"] = 2] = "EXPIRED";
    /**
     * @generated from protobuf enum value: CONSENT_STATUS_REVOKED = 3;
     */
    ConsentStatus[ConsentStatus["REVOKED"] = 3] = "REVOKED";
    /**
     * @generated from protobuf enum value: CONSENT_STATUS_SUPERSEDED = 4;
     */
    ConsentStatus[ConsentStatus["SUPERSEDED"] = 4] = "SUPERSEDED";
})(ConsentStatus || (ConsentStatus = {}));
/**
 * DocumentType categorizes legal documents
 *
 * @generated from protobuf enum legal.v1.DocumentType
 */
export var DocumentType;
(function (DocumentType) {
    /**
     * @generated from protobuf enum value: DOCUMENT_TYPE_UNSPECIFIED = 0;
     */
    DocumentType[DocumentType["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: DOCUMENT_TYPE_TERMS_OF_SERVICE = 1;
     */
    DocumentType[DocumentType["TERMS_OF_SERVICE"] = 1] = "TERMS_OF_SERVICE";
    /**
     * @generated from protobuf enum value: DOCUMENT_TYPE_PRIVACY_POLICY = 2;
     */
    DocumentType[DocumentType["PRIVACY_POLICY"] = 2] = "PRIVACY_POLICY";
    /**
     * @generated from protobuf enum value: DOCUMENT_TYPE_COOKIE_POLICY = 3;
     */
    DocumentType[DocumentType["COOKIE_POLICY"] = 3] = "COOKIE_POLICY";
    /**
     * @generated from protobuf enum value: DOCUMENT_TYPE_DATA_PROCESSING_AGREEMENT = 4;
     */
    DocumentType[DocumentType["DATA_PROCESSING_AGREEMENT"] = 4] = "DATA_PROCESSING_AGREEMENT";
    /**
     * @generated from protobuf enum value: DOCUMENT_TYPE_ACCEPTABLE_USE_POLICY = 5;
     */
    DocumentType[DocumentType["ACCEPTABLE_USE_POLICY"] = 5] = "ACCEPTABLE_USE_POLICY";
})(DocumentType || (DocumentType = {}));
/**
 * DsrType categorizes DSR requests
 *
 * @generated from protobuf enum legal.v1.DsrType
 */
export var DsrType;
(function (DsrType) {
    /**
     * @generated from protobuf enum value: DSR_TYPE_UNSPECIFIED = 0;
     */
    DsrType[DsrType["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: DSR_TYPE_ACCESS = 1;
     */
    DsrType[DsrType["ACCESS"] = 1] = "ACCESS";
    /**
     * @generated from protobuf enum value: DSR_TYPE_RECTIFICATION = 2;
     */
    DsrType[DsrType["RECTIFICATION"] = 2] = "RECTIFICATION";
    /**
     * @generated from protobuf enum value: DSR_TYPE_ERASURE = 3;
     */
    DsrType[DsrType["ERASURE"] = 3] = "ERASURE";
    /**
     * @generated from protobuf enum value: DSR_TYPE_PORTABILITY = 4;
     */
    DsrType[DsrType["PORTABILITY"] = 4] = "PORTABILITY";
    /**
     * @generated from protobuf enum value: DSR_TYPE_RESTRICTION = 5;
     */
    DsrType[DsrType["RESTRICTION"] = 5] = "RESTRICTION";
    /**
     * @generated from protobuf enum value: DSR_TYPE_OBJECTION = 6;
     */
    DsrType[DsrType["OBJECTION"] = 6] = "OBJECTION";
})(DsrType || (DsrType = {}));
/**
 * DsrStatus represents the state of a DSR
 *
 * @generated from protobuf enum legal.v1.DsrStatus
 */
export var DsrStatus;
(function (DsrStatus) {
    /**
     * @generated from protobuf enum value: DSR_STATUS_UNSPECIFIED = 0;
     */
    DsrStatus[DsrStatus["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: DSR_STATUS_PENDING = 1;
     */
    DsrStatus[DsrStatus["PENDING"] = 1] = "PENDING";
    /**
     * @generated from protobuf enum value: DSR_STATUS_IN_PROGRESS = 2;
     */
    DsrStatus[DsrStatus["IN_PROGRESS"] = 2] = "IN_PROGRESS";
    /**
     * @generated from protobuf enum value: DSR_STATUS_COMPLETED = 3;
     */
    DsrStatus[DsrStatus["COMPLETED"] = 3] = "COMPLETED";
    /**
     * @generated from protobuf enum value: DSR_STATUS_REJECTED = 4;
     */
    DsrStatus[DsrStatus["REJECTED"] = 4] = "REJECTED";
    /**
     * @generated from protobuf enum value: DSR_STATUS_EXPIRED = 5;
     */
    DsrStatus[DsrStatus["EXPIRED"] = 5] = "EXPIRED";
})(DsrStatus || (DsrStatus = {}));
// @generated message type with reflection information, may provide speed optimized methods
class Consent$Type extends MessageType {
    constructor() {
        super("legal.v1.Consent", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "consent_type", kind: "enum", T: () => ["legal.v1.ConsentType", ConsentType, "CONSENT_TYPE_"] },
            { no: 4, name: "document_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "document_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "status", kind: "enum", T: () => ["legal.v1.ConsentStatus", ConsentStatus, "CONSENT_STATUS_"] },
            { no: 7, name: "ip_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "user_agent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "agreed_at", kind: "message", T: () => Timestamp },
            { no: 10, name: "expires_at", kind: "message", T: () => Timestamp },
            { no: 11, name: "revoked_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.accountId = "";
        message.consentType = 0;
        message.documentId = "";
        message.documentVersion = "";
        message.status = 0;
        message.ipAddress = "";
        message.userAgent = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string account_id */ 2:
                    message.accountId = reader.string();
                    break;
                case /* legal.v1.ConsentType consent_type */ 3:
                    message.consentType = reader.int32();
                    break;
                case /* string document_id */ 4:
                    message.documentId = reader.string();
                    break;
                case /* string document_version */ 5:
                    message.documentVersion = reader.string();
                    break;
                case /* legal.v1.ConsentStatus status */ 6:
                    message.status = reader.int32();
                    break;
                case /* string ip_address */ 7:
                    message.ipAddress = reader.string();
                    break;
                case /* string user_agent */ 8:
                    message.userAgent = reader.string();
                    break;
                case /* google.protobuf.Timestamp agreed_at */ 9:
                    message.agreedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.agreedAt);
                    break;
                case /* google.protobuf.Timestamp expires_at */ 10:
                    message.expiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
                    break;
                case /* google.protobuf.Timestamp revoked_at */ 11:
                    message.revokedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.revokedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string account_id = 2; */
        if (message.accountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountId);
        /* legal.v1.ConsentType consent_type = 3; */
        if (message.consentType !== 0)
            writer.tag(3, WireType.Varint).int32(message.consentType);
        /* string document_id = 4; */
        if (message.documentId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.documentId);
        /* string document_version = 5; */
        if (message.documentVersion !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.documentVersion);
        /* legal.v1.ConsentStatus status = 6; */
        if (message.status !== 0)
            writer.tag(6, WireType.Varint).int32(message.status);
        /* string ip_address = 7; */
        if (message.ipAddress !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.ipAddress);
        /* string user_agent = 8; */
        if (message.userAgent !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.userAgent);
        /* google.protobuf.Timestamp agreed_at = 9; */
        if (message.agreedAt)
            Timestamp.internalBinaryWrite(message.agreedAt, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp expires_at = 10; */
        if (message.expiresAt)
            Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp revoked_at = 11; */
        if (message.revokedAt)
            Timestamp.internalBinaryWrite(message.revokedAt, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.Consent
 */
export const Consent = new Consent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LegalDocument$Type extends MessageType {
    constructor() {
        super("legal.v1.LegalDocument", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["legal.v1.DocumentType", DocumentType, "DOCUMENT_TYPE_"] },
            { no: 3, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "content_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "language_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "is_mandatory", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "effective_at", kind: "message", T: () => Timestamp },
            { no: 11, name: "expires_at", kind: "message", T: () => Timestamp },
            { no: 12, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.type = 0;
        message.version = "";
        message.title = "";
        message.content = "";
        message.contentHash = "";
        message.languageCode = "";
        message.countryCode = "";
        message.isMandatory = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* legal.v1.DocumentType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string version */ 3:
                    message.version = reader.string();
                    break;
                case /* string title */ 4:
                    message.title = reader.string();
                    break;
                case /* string content */ 5:
                    message.content = reader.string();
                    break;
                case /* string content_hash */ 6:
                    message.contentHash = reader.string();
                    break;
                case /* string language_code */ 7:
                    message.languageCode = reader.string();
                    break;
                case /* string country_code */ 8:
                    message.countryCode = reader.string();
                    break;
                case /* bool is_mandatory */ 9:
                    message.isMandatory = reader.bool();
                    break;
                case /* google.protobuf.Timestamp effective_at */ 10:
                    message.effectiveAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.effectiveAt);
                    break;
                case /* google.protobuf.Timestamp expires_at */ 11:
                    message.expiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
                    break;
                case /* google.protobuf.Timestamp created_at */ 12:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* legal.v1.DocumentType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string version = 3; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* string title = 4; */
        if (message.title !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.title);
        /* string content = 5; */
        if (message.content !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.content);
        /* string content_hash = 6; */
        if (message.contentHash !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.contentHash);
        /* string language_code = 7; */
        if (message.languageCode !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.languageCode);
        /* string country_code = 8; */
        if (message.countryCode !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.countryCode);
        /* bool is_mandatory = 9; */
        if (message.isMandatory !== false)
            writer.tag(9, WireType.Varint).bool(message.isMandatory);
        /* google.protobuf.Timestamp effective_at = 10; */
        if (message.effectiveAt)
            Timestamp.internalBinaryWrite(message.effectiveAt, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp expires_at = 11; */
        if (message.expiresAt)
            Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 12; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.LegalDocument
 */
export const LegalDocument = new LegalDocument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LawRequirements$Type extends MessageType {
    constructor() {
        super("legal.v1.LawRequirements", [
            { no: 1, name: "law_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "law_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "minimum_age", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "parental_consent_age", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "required_consents", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["legal.v1.ConsentType", ConsentType, "CONSENT_TYPE_"] },
            { no: 7, name: "dsr_deadline_days", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "data_retention_days", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "requires_explicit_consent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "allows_soft_opt_out", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.lawCode = "";
        message.countryCode = "";
        message.lawName = "";
        message.minimumAge = 0;
        message.parentalConsentAge = 0;
        message.requiredConsents = [];
        message.dsrDeadlineDays = 0;
        message.dataRetentionDays = 0;
        message.requiresExplicitConsent = false;
        message.allowsSoftOptOut = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string law_code */ 1:
                    message.lawCode = reader.string();
                    break;
                case /* string country_code */ 2:
                    message.countryCode = reader.string();
                    break;
                case /* string law_name */ 3:
                    message.lawName = reader.string();
                    break;
                case /* int32 minimum_age */ 4:
                    message.minimumAge = reader.int32();
                    break;
                case /* int32 parental_consent_age */ 5:
                    message.parentalConsentAge = reader.int32();
                    break;
                case /* repeated legal.v1.ConsentType required_consents */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.requiredConsents.push(reader.int32());
                    else
                        message.requiredConsents.push(reader.int32());
                    break;
                case /* int32 dsr_deadline_days */ 7:
                    message.dsrDeadlineDays = reader.int32();
                    break;
                case /* int32 data_retention_days */ 8:
                    message.dataRetentionDays = reader.int32();
                    break;
                case /* bool requires_explicit_consent */ 9:
                    message.requiresExplicitConsent = reader.bool();
                    break;
                case /* bool allows_soft_opt_out */ 10:
                    message.allowsSoftOptOut = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string law_code = 1; */
        if (message.lawCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.lawCode);
        /* string country_code = 2; */
        if (message.countryCode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.countryCode);
        /* string law_name = 3; */
        if (message.lawName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lawName);
        /* int32 minimum_age = 4; */
        if (message.minimumAge !== 0)
            writer.tag(4, WireType.Varint).int32(message.minimumAge);
        /* int32 parental_consent_age = 5; */
        if (message.parentalConsentAge !== 0)
            writer.tag(5, WireType.Varint).int32(message.parentalConsentAge);
        /* repeated legal.v1.ConsentType required_consents = 6; */
        if (message.requiredConsents.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.requiredConsents.length; i++)
                writer.int32(message.requiredConsents[i]);
            writer.join();
        }
        /* int32 dsr_deadline_days = 7; */
        if (message.dsrDeadlineDays !== 0)
            writer.tag(7, WireType.Varint).int32(message.dsrDeadlineDays);
        /* int32 data_retention_days = 8; */
        if (message.dataRetentionDays !== 0)
            writer.tag(8, WireType.Varint).int32(message.dataRetentionDays);
        /* bool requires_explicit_consent = 9; */
        if (message.requiresExplicitConsent !== false)
            writer.tag(9, WireType.Varint).bool(message.requiresExplicitConsent);
        /* bool allows_soft_opt_out = 10; */
        if (message.allowsSoftOptOut !== false)
            writer.tag(10, WireType.Varint).bool(message.allowsSoftOptOut);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.LawRequirements
 */
export const LawRequirements = new LawRequirements$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountryCompliance$Type extends MessageType {
    constructor() {
        super("legal.v1.CountryCompliance", [
            { no: 1, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "applicable_laws", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "strictest_requirements", kind: "message", T: () => LawRequirements },
            { no: 4, name: "gdpr_applicable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "ccpa_applicable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.countryCode = "";
        message.applicableLaws = [];
        message.gdprApplicable = false;
        message.ccpaApplicable = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string country_code */ 1:
                    message.countryCode = reader.string();
                    break;
                case /* repeated string applicable_laws */ 2:
                    message.applicableLaws.push(reader.string());
                    break;
                case /* legal.v1.LawRequirements strictest_requirements */ 3:
                    message.strictestRequirements = LawRequirements.internalBinaryRead(reader, reader.uint32(), options, message.strictestRequirements);
                    break;
                case /* bool gdpr_applicable */ 4:
                    message.gdprApplicable = reader.bool();
                    break;
                case /* bool ccpa_applicable */ 5:
                    message.ccpaApplicable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string country_code = 1; */
        if (message.countryCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.countryCode);
        /* repeated string applicable_laws = 2; */
        for (let i = 0; i < message.applicableLaws.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.applicableLaws[i]);
        /* legal.v1.LawRequirements strictest_requirements = 3; */
        if (message.strictestRequirements)
            LawRequirements.internalBinaryWrite(message.strictestRequirements, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool gdpr_applicable = 4; */
        if (message.gdprApplicable !== false)
            writer.tag(4, WireType.Varint).bool(message.gdprApplicable);
        /* bool ccpa_applicable = 5; */
        if (message.ccpaApplicable !== false)
            writer.tag(5, WireType.Varint).bool(message.ccpaApplicable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.CountryCompliance
 */
export const CountryCompliance = new CountryCompliance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DsrRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.DsrRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["legal.v1.DsrType", DsrType, "DSR_TYPE_"] },
            { no: 4, name: "status", kind: "enum", T: () => ["legal.v1.DsrStatus", DsrStatus, "DSR_STATUS_"] },
            { no: 5, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "submitted_at", kind: "message", T: () => Timestamp },
            { no: 7, name: "deadline_at", kind: "message", T: () => Timestamp },
            { no: 8, name: "completed_at", kind: "message", T: () => Timestamp },
            { no: 9, name: "processed_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.accountId = "";
        message.type = 0;
        message.status = 0;
        message.reason = "";
        message.processedBy = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string account_id */ 2:
                    message.accountId = reader.string();
                    break;
                case /* legal.v1.DsrType type */ 3:
                    message.type = reader.int32();
                    break;
                case /* legal.v1.DsrStatus status */ 4:
                    message.status = reader.int32();
                    break;
                case /* string reason */ 5:
                    message.reason = reader.string();
                    break;
                case /* google.protobuf.Timestamp submitted_at */ 6:
                    message.submittedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.submittedAt);
                    break;
                case /* google.protobuf.Timestamp deadline_at */ 7:
                    message.deadlineAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deadlineAt);
                    break;
                case /* google.protobuf.Timestamp completed_at */ 8:
                    message.completedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.completedAt);
                    break;
                case /* string processed_by */ 9:
                    message.processedBy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string account_id = 2; */
        if (message.accountId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountId);
        /* legal.v1.DsrType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* legal.v1.DsrStatus status = 4; */
        if (message.status !== 0)
            writer.tag(4, WireType.Varint).int32(message.status);
        /* string reason = 5; */
        if (message.reason !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.reason);
        /* google.protobuf.Timestamp submitted_at = 6; */
        if (message.submittedAt)
            Timestamp.internalBinaryWrite(message.submittedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp deadline_at = 7; */
        if (message.deadlineAt)
            Timestamp.internalBinaryWrite(message.deadlineAt, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp completed_at = 8; */
        if (message.completedAt)
            Timestamp.internalBinaryWrite(message.completedAt, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string processed_by = 9; */
        if (message.processedBy !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.processedBy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.DsrRequest
 */
export const DsrRequest = new DsrRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DsrDeadline$Type extends MessageType {
    constructor() {
        super("legal.v1.DsrDeadline", [
            { no: 1, name: "deadline", kind: "message", T: () => Timestamp },
            { no: 2, name: "days_remaining", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "is_overdue", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.daysRemaining = 0;
        message.isOverdue = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp deadline */ 1:
                    message.deadline = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deadline);
                    break;
                case /* int32 days_remaining */ 2:
                    message.daysRemaining = reader.int32();
                    break;
                case /* bool is_overdue */ 3:
                    message.isOverdue = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* google.protobuf.Timestamp deadline = 1; */
        if (message.deadline)
            Timestamp.internalBinaryWrite(message.deadline, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 days_remaining = 2; */
        if (message.daysRemaining !== 0)
            writer.tag(2, WireType.Varint).int32(message.daysRemaining);
        /* bool is_overdue = 3; */
        if (message.isOverdue !== false)
            writer.tag(3, WireType.Varint).bool(message.isOverdue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.DsrDeadline
 */
export const DsrDeadline = new DsrDeadline$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckConsentsRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.CheckConsentsRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "required_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["legal.v1.ConsentType", ConsentType, "CONSENT_TYPE_"] }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.accountId = "";
        message.countryCode = "";
        message.requiredTypes = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* string country_code */ 2:
                    message.countryCode = reader.string();
                    break;
                case /* repeated legal.v1.ConsentType required_types */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.requiredTypes.push(reader.int32());
                    else
                        message.requiredTypes.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* string country_code = 2; */
        if (message.countryCode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.countryCode);
        /* repeated legal.v1.ConsentType required_types = 3; */
        if (message.requiredTypes.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.requiredTypes.length; i++)
                writer.int32(message.requiredTypes[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.CheckConsentsRequest
 */
export const CheckConsentsRequest = new CheckConsentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckConsentsResponse$Type extends MessageType {
    constructor() {
        super("legal.v1.CheckConsentsResponse", [
            { no: 1, name: "all_required_granted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "missing_consents", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["legal.v1.ConsentType", ConsentType, "CONSENT_TYPE_"] },
            { no: 3, name: "expired_consents", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["legal.v1.ConsentType", ConsentType, "CONSENT_TYPE_"] },
            { no: 4, name: "active_consents", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Consent }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.allRequiredGranted = false;
        message.missingConsents = [];
        message.expiredConsents = [];
        message.activeConsents = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool all_required_granted */ 1:
                    message.allRequiredGranted = reader.bool();
                    break;
                case /* repeated legal.v1.ConsentType missing_consents */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.missingConsents.push(reader.int32());
                    else
                        message.missingConsents.push(reader.int32());
                    break;
                case /* repeated legal.v1.ConsentType expired_consents */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.expiredConsents.push(reader.int32());
                    else
                        message.expiredConsents.push(reader.int32());
                    break;
                case /* repeated legal.v1.Consent active_consents */ 4:
                    message.activeConsents.push(Consent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool all_required_granted = 1; */
        if (message.allRequiredGranted !== false)
            writer.tag(1, WireType.Varint).bool(message.allRequiredGranted);
        /* repeated legal.v1.ConsentType missing_consents = 2; */
        if (message.missingConsents.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.missingConsents.length; i++)
                writer.int32(message.missingConsents[i]);
            writer.join();
        }
        /* repeated legal.v1.ConsentType expired_consents = 3; */
        if (message.expiredConsents.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.expiredConsents.length; i++)
                writer.int32(message.expiredConsents[i]);
            writer.join();
        }
        /* repeated legal.v1.Consent active_consents = 4; */
        for (let i = 0; i < message.activeConsents.length; i++)
            Consent.internalBinaryWrite(message.activeConsents[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.CheckConsentsResponse
 */
export const CheckConsentsResponse = new CheckConsentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccountConsentsRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.GetAccountConsentsRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_revoked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "include_expired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.accountId = "";
        message.includeRevoked = false;
        message.includeExpired = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* bool include_revoked */ 2:
                    message.includeRevoked = reader.bool();
                    break;
                case /* bool include_expired */ 3:
                    message.includeExpired = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* bool include_revoked = 2; */
        if (message.includeRevoked !== false)
            writer.tag(2, WireType.Varint).bool(message.includeRevoked);
        /* bool include_expired = 3; */
        if (message.includeExpired !== false)
            writer.tag(3, WireType.Varint).bool(message.includeExpired);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetAccountConsentsRequest
 */
export const GetAccountConsentsRequest = new GetAccountConsentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccountConsentsResponse$Type extends MessageType {
    constructor() {
        super("legal.v1.GetAccountConsentsResponse", [
            { no: 1, name: "consents", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Consent },
            { no: 2, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.consents = [];
        message.totalCount = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated legal.v1.Consent consents */ 1:
                    message.consents.push(Consent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_count */ 2:
                    message.totalCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated legal.v1.Consent consents = 1; */
        for (let i = 0; i < message.consents.length; i++)
            Consent.internalBinaryWrite(message.consents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetAccountConsentsResponse
 */
export const GetAccountConsentsResponse = new GetAccountConsentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GrantConsentRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.GrantConsentRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "consent_type", kind: "enum", T: () => ["legal.v1.ConsentType", ConsentType, "CONSENT_TYPE_"] },
            { no: 3, name: "document_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ip_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "user_agent", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.accountId = "";
        message.consentType = 0;
        message.documentId = "";
        message.ipAddress = "";
        message.userAgent = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* legal.v1.ConsentType consent_type */ 2:
                    message.consentType = reader.int32();
                    break;
                case /* string document_id */ 3:
                    message.documentId = reader.string();
                    break;
                case /* string ip_address */ 4:
                    message.ipAddress = reader.string();
                    break;
                case /* string user_agent */ 5:
                    message.userAgent = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* legal.v1.ConsentType consent_type = 2; */
        if (message.consentType !== 0)
            writer.tag(2, WireType.Varint).int32(message.consentType);
        /* string document_id = 3; */
        if (message.documentId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.documentId);
        /* string ip_address = 4; */
        if (message.ipAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ipAddress);
        /* string user_agent = 5; */
        if (message.userAgent !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.userAgent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GrantConsentRequest
 */
export const GrantConsentRequest = new GrantConsentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GrantConsentResponse$Type extends MessageType {
    constructor() {
        super("legal.v1.GrantConsentResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "consent", kind: "message", T: () => Consent },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* legal.v1.Consent consent */ 2:
                    message.consent = Consent.internalBinaryRead(reader, reader.uint32(), options, message.consent);
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* legal.v1.Consent consent = 2; */
        if (message.consent)
            Consent.internalBinaryWrite(message.consent, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GrantConsentResponse
 */
export const GrantConsentResponse = new GrantConsentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RevokeConsentRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.RevokeConsentRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "consent_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.accountId = "";
        message.consentId = "";
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* string consent_id */ 2:
                    message.consentId = reader.string();
                    break;
                case /* string reason */ 3:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* string consent_id = 2; */
        if (message.consentId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.consentId);
        /* string reason = 3; */
        if (message.reason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.RevokeConsentRequest
 */
export const RevokeConsentRequest = new RevokeConsentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RevokeConsentResponse$Type extends MessageType {
    constructor() {
        super("legal.v1.RevokeConsentResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.RevokeConsentResponse
 */
export const RevokeConsentResponse = new RevokeConsentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCurrentDocumentRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.GetCurrentDocumentRequest", [
            { no: 1, name: "document_type", kind: "enum", T: () => ["legal.v1.DocumentType", DocumentType, "DOCUMENT_TYPE_"] },
            { no: 2, name: "language_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.documentType = 0;
        message.languageCode = "";
        message.countryCode = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* legal.v1.DocumentType document_type */ 1:
                    message.documentType = reader.int32();
                    break;
                case /* string language_code */ 2:
                    message.languageCode = reader.string();
                    break;
                case /* string country_code */ 3:
                    message.countryCode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* legal.v1.DocumentType document_type = 1; */
        if (message.documentType !== 0)
            writer.tag(1, WireType.Varint).int32(message.documentType);
        /* string language_code = 2; */
        if (message.languageCode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.languageCode);
        /* string country_code = 3; */
        if (message.countryCode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.countryCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetCurrentDocumentRequest
 */
export const GetCurrentDocumentRequest = new GetCurrentDocumentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCurrentDocumentResponse$Type extends MessageType {
    constructor() {
        super("legal.v1.GetCurrentDocumentResponse", [
            { no: 1, name: "document", kind: "message", T: () => LegalDocument }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* legal.v1.LegalDocument document */ 1:
                    message.document = LegalDocument.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* legal.v1.LegalDocument document = 1; */
        if (message.document)
            LegalDocument.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetCurrentDocumentResponse
 */
export const GetCurrentDocumentResponse = new GetCurrentDocumentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocumentVersionRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.GetDocumentVersionRequest", [
            { no: 1, name: "document_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.documentId = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string document_id */ 1:
                    message.documentId = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string document_id = 1; */
        if (message.documentId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.documentId);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetDocumentVersionRequest
 */
export const GetDocumentVersionRequest = new GetDocumentVersionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocumentVersionResponse$Type extends MessageType {
    constructor() {
        super("legal.v1.GetDocumentVersionResponse", [
            { no: 1, name: "document", kind: "message", T: () => LegalDocument }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* legal.v1.LegalDocument document */ 1:
                    message.document = LegalDocument.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* legal.v1.LegalDocument document = 1; */
        if (message.document)
            LegalDocument.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetDocumentVersionResponse
 */
export const GetDocumentVersionResponse = new GetDocumentVersionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDocumentsRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.ListDocumentsRequest", [
            { no: 1, name: "type", kind: "enum", T: () => ["legal.v1.DocumentType", DocumentType, "DOCUMENT_TYPE_"] },
            { no: 2, name: "language_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "include_expired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = 0;
        message.languageCode = "";
        message.includeExpired = false;
        message.pageSize = 0;
        message.pageToken = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* legal.v1.DocumentType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string language_code */ 2:
                    message.languageCode = reader.string();
                    break;
                case /* bool include_expired */ 3:
                    message.includeExpired = reader.bool();
                    break;
                case /* int32 page_size */ 4:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 5:
                    message.pageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* legal.v1.DocumentType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string language_code = 2; */
        if (message.languageCode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.languageCode);
        /* bool include_expired = 3; */
        if (message.includeExpired !== false)
            writer.tag(3, WireType.Varint).bool(message.includeExpired);
        /* int32 page_size = 4; */
        if (message.pageSize !== 0)
            writer.tag(4, WireType.Varint).int32(message.pageSize);
        /* string page_token = 5; */
        if (message.pageToken !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.ListDocumentsRequest
 */
export const ListDocumentsRequest = new ListDocumentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDocumentsResponse$Type extends MessageType {
    constructor() {
        super("legal.v1.ListDocumentsResponse", [
            { no: 1, name: "documents", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LegalDocument },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.documents = [];
        message.nextPageToken = "";
        message.totalCount = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated legal.v1.LegalDocument documents */ 1:
                    message.documents.push(LegalDocument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                case /* int32 total_count */ 3:
                    message.totalCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated legal.v1.LegalDocument documents = 1; */
        for (let i = 0; i < message.documents.length; i++)
            LegalDocument.internalBinaryWrite(message.documents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        /* int32 total_count = 3; */
        if (message.totalCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.totalCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.ListDocumentsResponse
 */
export const ListDocumentsResponse = new ListDocumentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLawRequirementsRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.GetLawRequirementsRequest", [
            { no: 1, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.countryCode = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string country_code */ 1:
                    message.countryCode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string country_code = 1; */
        if (message.countryCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.countryCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetLawRequirementsRequest
 */
export const GetLawRequirementsRequest = new GetLawRequirementsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLawRequirementsResponse$Type extends MessageType {
    constructor() {
        super("legal.v1.GetLawRequirementsResponse", [
            { no: 1, name: "requirements", kind: "message", T: () => LawRequirements }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* legal.v1.LawRequirements requirements */ 1:
                    message.requirements = LawRequirements.internalBinaryRead(reader, reader.uint32(), options, message.requirements);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* legal.v1.LawRequirements requirements = 1; */
        if (message.requirements)
            LawRequirements.internalBinaryWrite(message.requirements, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetLawRequirementsResponse
 */
export const GetLawRequirementsResponse = new GetLawRequirementsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCountryComplianceRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.GetCountryComplianceRequest", [
            { no: 1, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.countryCode = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string country_code */ 1:
                    message.countryCode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string country_code = 1; */
        if (message.countryCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.countryCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetCountryComplianceRequest
 */
export const GetCountryComplianceRequest = new GetCountryComplianceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCountryComplianceResponse$Type extends MessageType {
    constructor() {
        super("legal.v1.GetCountryComplianceResponse", [
            { no: 1, name: "compliance", kind: "message", T: () => CountryCompliance }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* legal.v1.CountryCompliance compliance */ 1:
                    message.compliance = CountryCompliance.internalBinaryRead(reader, reader.uint32(), options, message.compliance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* legal.v1.CountryCompliance compliance = 1; */
        if (message.compliance)
            CountryCompliance.internalBinaryWrite(message.compliance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetCountryComplianceResponse
 */
export const GetCountryComplianceResponse = new GetCountryComplianceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateDsrRequestRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.CreateDsrRequestRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["legal.v1.DsrType", DsrType, "DSR_TYPE_"] },
            { no: 3, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.accountId = "";
        message.type = 0;
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* legal.v1.DsrType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string reason */ 3:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* legal.v1.DsrType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string reason = 3; */
        if (message.reason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.CreateDsrRequestRequest
 */
export const CreateDsrRequestRequest = new CreateDsrRequestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateDsrRequestResponse$Type extends MessageType {
    constructor() {
        super("legal.v1.CreateDsrRequestResponse", [
            { no: 1, name: "dsr_request", kind: "message", T: () => DsrRequest }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* legal.v1.DsrRequest dsr_request */ 1:
                    message.dsrRequest = DsrRequest.internalBinaryRead(reader, reader.uint32(), options, message.dsrRequest);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* legal.v1.DsrRequest dsr_request = 1; */
        if (message.dsrRequest)
            DsrRequest.internalBinaryWrite(message.dsrRequest, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.CreateDsrRequestResponse
 */
export const CreateDsrRequestResponse = new CreateDsrRequestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDsrRequestRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.GetDsrRequestRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetDsrRequestRequest
 */
export const GetDsrRequestRequest = new GetDsrRequestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDsrRequestResponse$Type extends MessageType {
    constructor() {
        super("legal.v1.GetDsrRequestResponse", [
            { no: 1, name: "dsr_request", kind: "message", T: () => DsrRequest }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* legal.v1.DsrRequest dsr_request */ 1:
                    message.dsrRequest = DsrRequest.internalBinaryRead(reader, reader.uint32(), options, message.dsrRequest);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* legal.v1.DsrRequest dsr_request = 1; */
        if (message.dsrRequest)
            DsrRequest.internalBinaryWrite(message.dsrRequest, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetDsrRequestResponse
 */
export const GetDsrRequestResponse = new GetDsrRequestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDsrDeadlineRequest$Type extends MessageType {
    constructor() {
        super("legal.v1.GetDsrDeadlineRequest", [
            { no: 1, name: "dsr_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.dsrId = "";
        message.countryCode = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string dsr_id */ 1:
                    message.dsrId = reader.string();
                    break;
                case /* string country_code */ 2:
                    message.countryCode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string dsr_id = 1; */
        if (message.dsrId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dsrId);
        /* string country_code = 2; */
        if (message.countryCode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.countryCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetDsrDeadlineRequest
 */
export const GetDsrDeadlineRequest = new GetDsrDeadlineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDsrDeadlineResponse$Type extends MessageType {
    constructor() {
        super("legal.v1.GetDsrDeadlineResponse", [
            { no: 1, name: "deadline", kind: "message", T: () => DsrDeadline }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* legal.v1.DsrDeadline deadline */ 1:
                    message.deadline = DsrDeadline.internalBinaryRead(reader, reader.uint32(), options, message.deadline);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* legal.v1.DsrDeadline deadline = 1; */
        if (message.deadline)
            DsrDeadline.internalBinaryWrite(message.deadline, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message legal.v1.GetDsrDeadlineResponse
 */
export const GetDsrDeadlineResponse = new GetDsrDeadlineResponse$Type();
/**
 * @generated ServiceType for protobuf service legal.v1.LegalService
 */
export const LegalService = new ServiceType("legal.v1.LegalService", [
    { name: "CheckConsents", options: {}, I: CheckConsentsRequest, O: CheckConsentsResponse },
    { name: "GetAccountConsents", options: {}, I: GetAccountConsentsRequest, O: GetAccountConsentsResponse },
    { name: "GrantConsent", options: {}, I: GrantConsentRequest, O: GrantConsentResponse },
    { name: "RevokeConsent", options: {}, I: RevokeConsentRequest, O: RevokeConsentResponse },
    { name: "GetCurrentDocument", options: {}, I: GetCurrentDocumentRequest, O: GetCurrentDocumentResponse },
    { name: "GetDocumentVersion", options: {}, I: GetDocumentVersionRequest, O: GetDocumentVersionResponse },
    { name: "ListDocuments", options: {}, I: ListDocumentsRequest, O: ListDocumentsResponse },
    { name: "GetLawRequirements", options: {}, I: GetLawRequirementsRequest, O: GetLawRequirementsResponse },
    { name: "GetCountryCompliance", options: {}, I: GetCountryComplianceRequest, O: GetCountryComplianceResponse },
    { name: "CreateDsrRequest", options: {}, I: CreateDsrRequestRequest, O: CreateDsrRequestResponse },
    { name: "GetDsrRequest", options: {}, I: GetDsrRequestRequest, O: GetDsrRequestResponse },
    { name: "GetDsrDeadline", options: {}, I: GetDsrDeadlineRequest, O: GetDsrDeadlineResponse }
]);
